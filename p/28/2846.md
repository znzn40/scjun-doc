---
manual:WebAPI
version:0
lang:zh
rawUrl:https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent
---





`KeyboardEvent`对象描述了键盘的交互方式。 每个事件都描述了一个按键（Each event describes a key）；事件类型`keydown`，`keypress`与`keyup`可以确定是哪种事件在活动。

`KeyboardEvent`表示刚刚发生在按键上的事情。 当你需要处理文本输入的时候，使用 HTML5[input](%14413 "")事件代替。例如，用户使用手持系统如平板电脑输入时， 按键事件可能不会触发。

## 构造器<a name="构造器"></a>
<dl><dt>[`KeyboardEvent()`](%14414 "KeyboardEvent() 构造函数新建一个 KeyboardEvent 实例。")</dt><dd>创建一个`KeyboardEvent`对象。</dd></dl>
## 方法<a name="方法"></a>


<em>本接口同样会继承对象父代的方法，[`UIEvent`](%3254 "UIEvent 接口表示简单的用户界面事件。")和[`Event`](%2693 "此页面仍未被本地化, 期待您的翻译!")。</em>

<dl><dt>[`KeyboardEvent.getModifierState()`](%14415 "此页面仍未被本地化, 期待您的翻译!")</dt><dd>返回一个[`Boolean`](%4930 "此页面仍未被本地化, 期待您的翻译!")，表示在事件创建时，修改键如<kbd>Alt</kbd>，<kbd>Shift</kbd>，<kbd>Ctrl</kbd>，<kbd>Meta</kbd>等是否按下。</dd><dt>[`KeyboardEvent.initKeyEvent()`](%14416 "此页面仍未被本地化, 期待您的翻译!")<i></i></dt><dd>初始化一个`KeyboardEvent`对象。Gecko 浏览器从来没有实现过本方法，其曾经使用过[`KeyboardEvent.initKeyboardEvent()`](%14417 "此页面仍未被本地化, 期待您的翻译!")方法，但是以后大概都不会再使用。 现在的标准方式是使用[`KeyboardEvent()`](%14414 "KeyboardEvent() 构造函数新建一个 KeyboardEvent 实例。")构造器。</dd><dt>[`KeyboardEvent.initKeyboardEvent()`](%14417 "此页面仍未被本地化, 期待您的翻译!")<i></i></dt><dd>初始化一个`KeyboardEvent`对象。Gecko 浏览器从来没有实现过本方法，其曾经使用过[`KeyboardEvent.initKeyEvent()`](%14416 "此页面仍未被本地化, 期待您的翻译!")方法，但是以后大概都不会再使用。 现在的标准方式是使用[`KeyboardEvent()`](%14414 "KeyboardEvent() 构造函数新建一个 KeyboardEvent 实例。")构造器。</dd></dl>
## 属性<a name="属性"></a>


<em>本接口同样会继承对象父代的属性，[`UIEvent`](%3254 "UIEvent 接口表示简单的用户界面事件。")和[`Event`](%2693 "此页面仍未被本地化, 期待您的翻译!")。</em>

<dl><dt>[`KeyboardEvent.altKey`](%14418 "KeyboardEvent.altKey 只读属性返回一个 Boolean 值，表示事件触发时 alt 键 (OS X系统上的 Option 或 ⌥ 键) 是 (true) 否 (false) 被按下。")只读</dt><dd>如果在生成按键事件时<kbd>Alt</kbd>(<kbd>Option</kbd>或 OS X 的<kbd>⌥</kbd>) 处于活动状态，则返回一个[`Boolean`](%4930 "此页面仍未被本地化, 期待您的翻译!")。</dd><dt>[`KeyboardEvent.char`](%14419 "此页面仍未被本地化, 期待您的翻译!")<i></i><i></i>只读</dt><dd>返回一个表示按键的字符值的[`DOMString`](%2651 "DOMString 是一个UTF-16字符串。由于JavaScript已经使用了这样的字符串，所以DOMString 直接映射到 一个String。")。如果该按键对应于可打印字符, 则此值是一个包含该字符的非空 Unicode 字符串。如果该按键没有可打印的表示形式, 则为空字符串。如果该按键用作插入多个字符的宏, 则此属性的值是整个字符串, 而不仅仅是第一个字符。
**注意:**DOM Level 3 中已丢弃. 仅支持 IE9+.
</dd><dt>[`KeyboardEvent.charCode`](%14420 "KeyboardEvent.charCode 只读属性，返回 keypress 事件触发时按下的字符键的字符Unicode值。")<i></i>只读</dt><dd>返回一个表示按键的 Unicode 编码的[`Number`](%10157 "JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。Number 对象由 Number() 构造器创建。")； 此属性仅由`keypress`事件使用。对于其 char 属性包含多个字符的按键是该属性中第一个字符的 Unicode 值。在火狐26中, 将返回可打印字符的代码。**注意:**此属性已被弃用; 用[`KeyboardEvent.key`](%14421 "KeyboardEvent.key 返回用户按下的键盘物理按键的值。值的决定方式：")代替（如果可用）。
</dd><dt>[`KeyboardEvent.code`](%14422 "as opposed to the character generated by pressing the key）。In other words, this property returns a value which isn't altered by keyboard layout or the state of the modifier keys.")只读</dt><dd>返回一个用事件表示值的[`DOMString`](%2651 "DOMString 是一个UTF-16字符串。由于JavaScript已经使用了这样的字符串，所以DOMString 直接映射到 一个String。")。</dd><dt>[`KeyboardEvent.ctrlKey`](%14423 "KeyboardEvent.ctrlKey 只读属性返回一个 Boolean 值，表示事件触发时 control 键是 (true) 否(false)按下。")只读</dt><dd>如果在生成按键事件时<kbd>Ctrl</kbd>键处于活动状态，则返回一个[`Boolean`](%4930 "此页面仍未被本地化, 期待您的翻译!")。</dd><dt>[`KeyboardEvent.isComposing`](%14424 "KeyboardEvent.isComposing 只读属性，返回一个 Boolean 值，表示该事件是否在 compositionstart 之后和 compositionend 之前被触发。")只读</dt><dd>如果事件在`[compositionstart](%14425 "")`之后或`[compositionend](%14426 "")`之前被触发，则返回一个[`Boolean`](%4930 "此页面仍未被本地化, 期待您的翻译!")。</dd><dt>[`KeyboardEvent.key`](%14421 "KeyboardEvent.key 返回用户按下的键盘物理按键的值。值的决定方式：")只读</dt><dd>返回一个事件表示键值的[`DOMString`](%2651 "DOMString 是一个UTF-16字符串。由于JavaScript已经使用了这样的字符串，所以DOMString 直接映射到 一个String。")。</dd><dt>[`KeyboardEvent.keyCode`](%14427 "该功能已从Web标准中删除。 尽管一些浏览器可能仍然支持它，但它正在被丢弃。 避免使用它并尽可能更新现有的代码; 请参阅本页底部的兼容性表格来指导您的决定。 请注意，此功能可能随时停止工作。")<i></i>只读</dt><dd>返回一个表示系统和实现相关的数字代码的[`Number`](%10157 "JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。Number 对象由 Number() 构造器创建。")，用于标识按键的未修改值。**注意:**此属性已被弃用;用[`KeyboardEvent.key`](%14421 "KeyboardEvent.key 返回用户按下的键盘物理按键的值。值的决定方式：")代替（如果可用）。
</dd><dt>[`KeyboardEvent.keyIdentifier`](%14428 "此页面仍未被本地化, 期待您的翻译!")<i></i><i></i>只读</dt><dd>此属性已弃用，建议使用[`KeyboardEvent.key`](%14421 "KeyboardEvent.key 返回用户按下的键盘物理按键的值。值的决定方式："). 它 是DOM Level 3 Events旧版的一部分。</dd><dt>[`KeyboardEvent.keyLocation`](%14429 "此页面仍未被本地化, 期待您的翻译!")<i></i><i></i>只读</dt><dd>这是[`KeyboardEvent.location`](%14430 "此页面仍未被本地化, 期待您的翻译!")的非标准否决别名.它也是DOM Level 3 Events旧版的一部分。</dd><dt>[`KeyboardEvent.locale`](%14431 "此页面仍未被本地化, 期待您的翻译!")只读</dt><dd>返回一个表示区域的[`DOMString`](%2651 "DOMString 是一个UTF-16字符串。由于JavaScript已经使用了这样的字符串，所以DOMString 直接映射到 一个String。")。 如果浏览器不知道或设备不知道，则可能为空字符串。它不描述所输入数据的区域设置。用户可以使用一个键盘布局键入不同语言的文本。
</dd><dt>[`KeyboardEvent.location`](%14430 "此页面仍未被本地化, 期待您的翻译!")</dt><dd>返回一个表示键盘或其他输入设备上按键位置的[`Number`](%10157 "JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。Number 对象由 Number() 构造器创建。")。</dd><dt>[`KeyboardEvent.metaKey`](%14432 "KeyboardEvent.metaKey 为只读属性，返回一个 布尔值，在事件发生时，用于指示 Meta 键是按下状态（true），还是释放状态（false）。")只读</dt><dd>如果<kbd>Meta</kbd>key (Mac上是<kbd>⌘ Command</kbd>键; Windows上是<kbd>⊞</kbd>键) 在生成按键事件时是活动的，则返回一个[`Boolean`](%4930 "此页面仍未被本地化, 期待您的翻译!")。</dd><dt>[`KeyboardEvent.repeat`](%14433 "KeyboardEvent.repeat是一个只读属性，返回一个布尔值Boolean，如果按键被一直按住，返回值为true。")只读</dt><dd>返回一个[`Boolean`](%4930 "此页面仍未被本地化, 期待您的翻译!")，如果该按键被保持为自动重复, 则该值为 true。</dd><dt>[`KeyboardEvent.shiftKey`](%14434 "KeyboardEvent.shiftKey 只读属性返回一个 Boolean 值，表示事件触发时 shift 键是 (true) 否(false)按下。")只读</dt><dd>返回一个[`Boolean`](%4930 "此页面仍未被本地化, 期待您的翻译!")，如果在生成按键事件时<kbd>shift</kbd>键处于活动状态, 则为 true。</dd><dt>[`KeyboardEvent.which`](%14435 "此页面仍未被本地化, 期待您的翻译!")<i></i>只读</dt><dd>返回一个表示系统和实现相关的数字代码[`Number`](%10157 "JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。Number 对象由 Number() 构造器创建。")用于标识按键的未修改值，通常与`keyCode`相同。**注意:**此属性已弃用； 请用[`KeyboardEvent.key`](%14421 "KeyboardEvent.key 返回用户按下的键盘物理按键的值。值的决定方式：")代替（如果可用）。
</dd></dl>
## 注意事项<a name="注意事项"></a>


它有`keydown事件`,`keypress`事件和`keyup`事件可用。通常Gecko这样派出事件:


1. 当按键被按下时, 发送`keydown`事件。
1. 如果该按键不是修饰键, 发送`keypress`事件。
1. 当按键被释放时, 发送`keyup`事件。

### 特殊情况<a name="特殊情况"></a>


一些按键能切换指示灯的状态，如Caps Lock键，Num Lock键和Scroll Lock键。在Windows和Linux上，这些按键仅发送`keydown`事件和`keyup`事件。



在 Linux上，Firefox 12 及其更早的版本也为这些按键发送了`keypress`事件。




但是，由于 MAC OS X 事件模型限制，Caps Lock键仅发送`keydown`事件。Num Lock键已支持旧的MacBook (2007和更旧的) ，但Mac至今都不支持Num Lock功能及外接键盘。在有Num Lock键的旧Macbook上 Num Lock 键不会触发任何事件。如果外接键盘有F14连接的话 Gecko 就支持 Scroll Lock键。在某个旧版本的 Firefox 里，这个键仅会触发`keypress`事件。详见[bug 602812](%14436 "FIXED: Inconsistency whether keypress event is dispatched or not of CapsLock, NumLock and ScrollLock keys")。


### 自动重复处理<a name="自动重复处理"></a>


当按键被按下并被按住时开始自动重复。这将导致一系列事件被发送：


1. `keydown`
1. `keypress`
1. `keydown`
1. `keypress`
1. &lt;&lt;repeating until the user releases the key&gt;&gt;
1. `keyup`


这是DOM Level 3标准所说的应该发生的事情。但是需要注意一下，如下所述。


#### Ubuntu 9.4 等 GTK 环境下的自动重复<a name="Ubuntu_9.4_等_GTK_环境下的自动重复"></a>


在一些基于GTK的环境中，自动重复在此期间自动发送一个本地的key-up事件，并且无法让 Gecko 知道重复的按键和自动重复的区别。在这些平台上，自动重复键将生成以下事件序列：


1. `keydown`
1. `keypress`
1. `keyup`
1. `keydown`
1. `keypress`
1. `keyup`
1. &lt;&lt;repeating until the user releases the key&gt;&gt;
1. `keyup`


不幸的是, 在这些环境中 web 内容无法区分自动重复键和正被反复按下的键之间的区别。


#### Gecko 5.0之前的自动重复处理<a name="Gecko_5.0之前的自动重复处理"></a>


在Gecko 5.0 (Firefox 5.0 / Thunderbird 5.0 / SeaMonkey 2.2)之前，键盘处理在平台之间的一致性较差。

<dl><dt>Windows</dt><dd>自动重复行为与Gecko 4.0和更高版本相同。</dd><dt>Mac</dt><dd>在初始keydown事件之后，只发送keypress事件直到发生keyup事件；不发送 inter-spaced keydown事件。</dd><dt>Linux</dt><dd>事件行为取决于特定的平台。由于事件模型不同, 它的行为可能与 Windows 或 Mac 类似。</dd></dl>

注意：手动触发事件不会生成与该事件关联的默认操作。 例如，手动触发键事件不会导致该字母出现在聚焦的文本输入中。 在UI事件中，出于安全性的原因，会阻止脚本模拟的用户操作与浏览器进行交互。



## 示例<a name="示例"></a>

```
<!DOCTYPE html>
<html>
<head>
<script>
'use strict';

document.addEventListener('keydown', (event) => {
  const keyName = event.key;

  if (keyName === 'Control') {
    // do not alert when only Control key is pressed.
    return;
  }

  if (event.ctrlKey) {
    // Even though event.key is not 'Control' (i.e. 'a' is pressed),
    // event.ctrlKey may be true if Ctrl key is pressed at the time.
    alert(`Combination of ctrlKey + ${keyName}`);
  } else {
    alert(`Key pressed ${keyName}`);
  }
}, false);

document.addEventListener('keyup', (event) => {
  const keyName = event.key;

  // As the user release the Ctrl key, the key is no longer active.
  // So event.ctrlKey is false.
  if (keyName === 'Control') {
    alert('Control key was released');
  }
}, false);
</script>
</head>

<body>
</body>
</html>
```

## 标准<a name="标准"></a>
标准 | 状态 | 说明 
[Document Object Model (DOM) Level 3 Events Specification<br></br><small>KeyboardEvent</small>](%14437 "") | Obsolete | 初始定义。 



`KeyboardEvent`接口标准经历了许多草稿版本, 首先在 DOM Events Level 2 下由于没有协商一致，它被丢弃； DOM Events Level 3重新加入.。这导致了在早期的DOM Events Level 2 版本中非标准初始化方法的实现，[`KeyboardEvent.initKeyEvent()`](%14416 "此页面仍未被本地化, 期待您的翻译!")实现在 Gecko 浏览器和早期 DOM Events Level 3 版本,[`KeyboardEvent.initKeyboardEvent()`](%14417 "此页面仍未被本地化, 期待您的翻译!")则实现在其他上。这两者都被现代使用构造函数所取代:[`KeyboardEvent()`](%14414 "KeyboardEvent() 构造函数新建一个 KeyboardEvent 实例。").


## 浏览器支持<a name="浏览器支持"></a>


其他页面上提供了更多兼容性数据:


* `.code`-参阅浏览器兼容性[`KeyboardEvent.code`](%14422 "as opposed to the character generated by pressing the key）。In other words, this property returns a value which isn't altered by keyboard layout or the state of the modifier keys.").
* `.key`-参阅浏览器兼容性[`KeyboardEvent.key`](%14421 "KeyboardEvent.key 返回用户按下的键盘物理按键的值。值的决定方式：").
* `.getModifierState()`-参阅浏览器兼容性[`KeyboardEvent.getModifierState`](%14415 "此页面仍未被本地化, 期待您的翻译!")


**[We&#39;re converting our compatibility data into a machine-readable JSON format](%3344 "")**. This compatibility table still uses the old format, because we haven&#39;t yet converted the data it contains.**[Find out how you can help!](%3392 "")**


* 
* 
功能 | Chrome | Firefox (Gecko) | Internet Explorer | Opera | Safari (WebKit) 
Basic support | (Yes) | (Yes) | (Yes) | (Yes) | (Yes) 
constructor | (Yes) | [31.0](%4423 "Released on 2014-07-22.")(31.0) | 未实现 | (Yes) | ? 
`.char` | 未实现 | 未实现 | 9 | 未实现 | 未实现 
`.charCode` | (Yes) | (Yes) | (Yes) | (Yes) | (Yes) 
`.isComposing` | 未实现 | [31.0](%4423 "Released on 2014-07-22.")(31.0) | 未实现 | 未实现 | 未实现 
`.keyCode` | (Yes) | (Yes) | (Yes) | (Yes) | (Yes) 
`.locale` | 未实现 | 未实现 | (Yes) | 未实现 | 未实现 
`.location` | (Yes) | [15.0](%10863 "Released on 2012-08-28.")(15.0) | (Yes) | 未实现 | 未实现 
`.repeat` | (Yes) | [28.0](%13502 "Released on 2014-03-18.")(28.0) | (Yes) | 未实现 | 未实现 
`.which` | (Yes) | (Yes) | (Yes) | (Yes) | (Yes) 
`.initKeyboardEvent()` | (Yes)<sup>[1]</sup> | 未实现<sup>[2]</sup> | 9.0<sup>[3]</sup> | ? | (Yes)<sup>[1]</sup> 





[1] WebKit 和 Blink的`initKeyboardEvent()的参数与`DOM Level 3 Events中的定义不同：`initKeyboardEvent(in DOMString typeArg, in boolean canBubbleArg, in boolean cancelableArg, in views::AbstractView viewArg, in DOMString keyIdentifierArg, in number locationArg, in boolean ctrlKeyArg, in boolean altKeyArg, in boolean shiftKeyArg, in boolean metaKeyArg, in boolean altGraphKeyArg)`



[2] Gecko 不支持`initKeyboardEvent()`，因为支持它完全中断了 web 应用程序的功能检测。详见[bug 999645](%14438 "FIXED: KeyboardEvent.initKeyboardEvent requires too many arguments").



[3]`IE的initKeyboardEvent()`的参数也与DOM Level 3 Events中的定义不同：`initKeyboardEvent(in DOMString typeArg, in boolean canBubbleArg, in boolean cancelableArg, in views::AbstractView viewArg, in DOMString keyArg, in number locationArg, in DOMString modifierListArg, in boolean repeatArt, in DOMString locationArg)`. See[document of`initKeyboardEvent()`in MSDN](%14439 "").



[[4]](%14440 "")注意, 手动触发事件不会生成与该事件关联的默认操作。例如,手动触发键事件不会导致该字母出现在焦点文本输入中。在UI events下,这很重要, 因为它可以防止脚本模拟与浏览器本身交互的用户操作。


## See also<a name="See_also"></a>

* [`KeyboardEvent.code`](%14422 "as opposed to the character generated by pressing the key）。In other words, this property returns a value which isn't altered by keyboard layout or the state of the modifier keys.").
* [`KeyboardEvent.key`](%14421 "KeyboardEvent.key 返回用户按下的键盘物理按键的值。值的决定方式：").
* [`KeyboardEvent.getModifierState`](%14415 "此页面仍未被本地化, 期待您的翻译!")



## 文档标签和贡献者
**标签：**
* [API](%50 "")
* [DOM](%456 "")
* [Event](%4963 "")
* [JavaScript](%2511 "")
* [事件](%14441 "")
* [键盘事件](%14442 "")

**此页面的贡献者：**[Ende93](%130 ""),[522211qaa](%14443 ""),[teoli](%160 ""),[ziyunfei](%61 "")
**最后编辑者:**[Ende93](%130 ""),<time>Aug 16, 2017, 6:06:17 PM</time>


