---
manual:Javascript
version:0
lang:zh
rawUrl:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Index#Difference_to_Object.preventExtensions()
---




## MDN JavaScript pages<a name="MDN_JavaScript_pages"></a>


该页面列出了 MDN JavaScript 所有的页面及相关概览和标签。



**Found 765 pages:**


# | Page | Tags and summary 
 ---  |  ---  |  ---  | 
1 | [JavaScript]27624 "") | **JavaScript, Landing** 
本部分将专注于 JavaScript 语言本身，而非局限于网页或其他宿主环境。想要了解网页有关的[APIs]445 "APIs: An API (Application Programming Interface) is a set of features and rules that exist inside a software program enabling interaction between the software and other items, such as other software or hardware.")，请参考[Web APIs]2510 "")以及[DOM]40763 "")。 

2 | [JavaScript shells编程环境]44193 "") | **JavaScript, 工具, 扩展** 
JavaScript shell可以让你在不刷新一个网页的情况下测试一段[JavaScript]14321 "")代码。这在开发和调试代码的时候非常有帮助。 

3 | [JavaScript 中的相等性判断]40512 "") | **JavaScr, 严格相等, 同值相等, 比较, 相等, 零值相等, 非严格相等** 
ES2015中有四种相等算法： 

4 | [JavaScript 参考文档]40518 "") | **JavaScript** 
本章介绍如何使用[JavaScript函数]40645 "")来开发应用程序。 

5 | [JavaScript 属性索引]40754 "") | **JavaScript** 
**No summary!** 

6 | [JavaScript 方法索引]40753 "") | **JavaScript** 
这篇文章按照字母顺序列出了MDN里边所有的JavaScript方法。 

7 | [JavaScript 标准库]40519 "") | **JavaScript, OOP, Reference** 
**No summary!** 

8 | [Array]40520 "") | **JavaScript, two-dimensional array, 二维数组, 数组** 
JavaScript`**Array**`对象是用于构造数组的全局对象; 它是高阶的、类似于列表的对象。 

9 | [Array.from()]3617 "") | **...rest, ...spread, Array, Array.from(), ECMAScript 2015, JavaScript, Reference, arguments, polyfill** 
`**Array.from()**`方法从一个类似数组或可迭代对象中创建一个新的数组实例。 

10 | [Array.isArray()]41567 "") | **ECMAScript5, JavaScript, brush: js, class=, polyfill, 数组, 方法** 
**Array.isArray()**用于确定传递的值是否是一个[`Array`]6708 "entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。")。 

11 | [Array.length]41673 "") | **JavaScript, 参考, 属性, 数组** 
Technical review completed. Editorial review completed. 

12 | [Array.observe()]41675 "") | **JavaScript, 实验性, 数组, 方法, 过时的** 
**Array.observe()**方法用于异步监视数组发生的变化，类似于针对对象的[`Object.observe()`]42235 "Object.observe() 方法用于异步地监视一个对象的修改。当对象属性被修改时，方法的回调函数会提供一个有序的修改流。然而，这个接口已经被废弃并从各浏览器中移除。你可以使用更通用的 Proxy 对象替代。")。当数组的值发生变化时，它按发生顺序提供了一个变化流。与`Object.observe()`类似，它由如下可接受的变化类型列表`["add"、"update"、"delete"、"splice"]`触发。 

13 | [Array.of()]3619 "") | **Array, Array.of(), ECMAScript 2015, ES 6, JavaScript, polyfill, 方法** 
`**Array.of()**`方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。 

14 | [Array.prototype]26542 "") | **Array.prototype** 
**`Array.prototype`**属性表示[`Array`]6708 "entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。")构造函数的原型，并允许您向所有Array对象添加新的属性和方法。 

15 | [Array.prototype.concat()]41382 "") | **JavaScript, 原型, 数组, 方法** 
`**concat()**`方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 

16 | [Array.prototype.copyWithin()]3626 "") | **Array.prototype.copyWithin(), ECMAScript6, JavaScript, polyfill, 原型, 数组, 方法, 浅复制** 
改变了的数组。 

17 | [Array.prototype.entries()]3628 "") | **Array.prototype.entries()** 
`**entries()**`方法返回一个新的**Array Iterator**对象，该对象包含数组中每个索引的键/值对。 

18 | [Array.prototype.every()]3630 "") | **** 
`**every()**`方法测试数组的所有元素是否都通过了指定函数的测试。 

19 | [Array.prototype.fill()]3632 "") | **Array, ECMAScript6, JavaScript, Method, polyfill** 
`**fill()**`方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。 

20 | [Array.prototype.filter()]3634 "") | **** 
`**filter()**`方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 

21 | [Array.prototype.find()]3636 "") | **ECMAScript6, JavaScript, polyfill, 数组, 方法** 
`**find()**`方法返回数组中满足提供的测试函数的第一个元素的值。否则返回[`undefined`]23495 "undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。")。 

22 | [Array.prototype.findIndex()]3638 "") | **Array, JavaScript, Method, Prototype** 
`**findIndex()**`方法返回数组中满足提供的测试函数的第一个元素的**索引**。否则返回-1。 

23 | [Array.prototype.forEach()]3640 "") | **ECMAScript5, JavaScript, Key, for-in, for-of, forEach, polyfill, value, 兼容旧环境, 原型, 参考, 对象数组, 对象数组： [{, 数组, 方法** 
`**forEach()**`方法对数组的每个元素执行一次提供的函数。 

24 | [Array.prototype.includes()]3642 "") | **Array, Array.prototype.includes(), ECMAScript 2016, JavaScript, 数组, 方法** 
`**includes()**`方法用来判断一个数组是否包含一个指定的值，如果是，酌情返回 true或 false。 

25 | [Array.prototype.indexOf()]3644 "") | **JavaScript, polyfill, 原型, 参考, 数组, 方法** 
`**indexOf()**`方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 

26 | [Array.prototype.join()]3646 "") | **Array, Array.prototype.join(), join(), separator** 
`**join()**`方法将数组（或一个[类数组对象]44194 "")）的所有元素连接到一个字符串中。 

27 | [Array.prototype.keys()]3648 "") | **&lt;pre class=, &gt;, Array, Array.prototype.keys(), ECMAScript6, Experimental, Expérimental(2), Iterator, JavaScript, Method, Prototype, brush: js** 
`**keys()**`方法返回一个新的Array迭代器，它包含数组中每个索引的键。 

28 | [Array.prototype.lastIndexOf()]3650 "") | **** 
`**lastIndexOf()**`方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从`fromIndex`处开始。 

29 | [Array.prototype.map()]3652 "") | **Array, ECMAScript5, JavaScript, Prototype, forEach, map(), polyfill, 原型, 数组, 方法** 
`**map()**`方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 

30 | [Array.prototype.pop()]41384 "") | **Array, Array.prototype.pop(), ES5, ES6, Prototype** 
`**pop()**方法从数组中**删除**最后一个**元素**，并**返回**该元素的**值**。此方法**更改**数组的**长度**。` 

31 | [Array.prototype.push()]41383 "") | **Array, Array.prototype.push(), JavaScript, Method, Prototype, 参考, 数组, 方法** 
`**push()**`方法将一个或多个元素添加到数组的末尾，并返回新数组的长度。 

32 | [Array.prototype.reduce()]41678 "") | **Array, ECMAScript 5, JavaScript, Method, Prototype, Reduce, Reference** 
`**reduce()**`方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。 

33 | [Array.prototype.reduce()]44195 "") | **** 
`**reduce()**`方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。 

34 | [Array.prototype.reduceRight()]41679 "") | **Array.prototype.reduceRight()** 
`**reduceRight()**`方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。 

35 | [Array.prototype.reverse()]3659 "") | **Array, Array.prototype.reverse(), JavaScript, 原型, 数组, 方法** 
`**reverse()**`方法将数组中元素的位置颠倒。 

36 | [Array.prototype.shift()]41385 "") | **Array.prototype.shift(), JavaScript, 原型, 数组, 方法** 
`**shift()**`方法从数组中**删除**第一个元素，并返回该元素的值。此方法更改数组的长度。 

37 | [Array.prototype.slice()]3662 "") | **Array, Array.prototype.slice(), JavaScript, Prototype, chunky-monkey, for in, for of, forEach, keys(), objects to array, 原型, 数组, 方法, 浅拷贝** 
`**slice()**`方法返回一个从开始到结束（***不包括结束***）选择的数组的一部分**浅拷贝**到一个新数组对象。原始数组不会被修改。 

38 | [Array.prototype.some()]3664 "") | **Array.prototype.some()** 
`**some()**`方法测试数组中的某些元素是否通过由提供的函数实现的测试。 

39 | [Array.prototype.sort()]3666 "") | **Array, Array.prototype.sort()排序算法, JavaScript, Prototype, 原型, 排序算法, 数组, 方法** 
`**sort()**`方法在适当的位置对数组的元素进行排序，并返回数组。 sort 排序不一定是[稳定的]44196 "")。默认排序顺序是根据字符串Unicode码点。 

40 | [Array.prototype.splice()]41386 "") | **Array, Array.prototype.splice(), JavaScript, 参考, 数组, 方法** 
**`splice()`******方法通过删除现有元素和/或添加新元素来更改一个数组的内容。 

41 | [Array.prototype.toLocaleString()]3671 "") | **** 
`**toLocaleString()**`返回一个字符串表示数组中的元素。数组中的元素将使用各自的`toLocaleString`方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 &quot;,&quot;）隔开。 

42 | [Array.prototype.toSource()]41680 "") | **** 
返回一个字符串,代表该数组的源代码. 

43 | [Array.prototype.toString()]3673 "") | **** 
`**toString()**`返回一个字符串，表示指定的数组及其元素。 

44 | [Array.prototype.unshift()]41681 "") | **Array, Array.prototype.unshift(), ES6, unshift()** 
**`unshift()`**方法将一个或多个元素添加到数组的开头，并返回新数组的长度。 

45 | [Array.prototype.values()]3669 "") | **Array, Array.prototype.values(), Chrome 未实现, ECMAScript6, Iterator, JavaScript, Prototype, 数组, 方法, 迭代** 
**`values()`**方法返回一个新的**`Array Iterator`**对象，该对象包含数组每个索引的值。 

46 | [Array.prototype[@@iterator]()]41682 "") | **Array, ECMAScript6, Iterator, JavaScript, Method, Prototype, 数组, 方法, 迭代** 
@@iterator属性和[`values()`]3669 "values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。")属性的初始值均为同一个函数对象 

47 | [Array.prototype[@@unscopables]]41674 "") | **Array, ECMAScript6, JavaScript, Property, Prototype, 数组, 方法** 
Symbol属性 @@unscopable 包含了所有 ES2015 (ES6) 中新定义的且并未被更早的 ECMAScript 标准收纳的属性名。这些属性并不包含在`[with]40942 "")`语句绑定的环境中 

48 | [Array.unobserve()]41683 "") | **** 
Array**.unobserve()方法用来移除**[`Array.observe()`]41675 "Array.observe() 方法用于异步监视数组发生的变化，类似于针对对象的 Object.observe() 。当数组的值发生变化时，它按发生顺序提供了一个变化流。与 Object.observe() 类似，它由如下可接受的变化类型列表["add"、"update"、"delete"、"splice"]触发。")设置的所有观察者。 

49 | [constructor]44197 "") | **** 
**No summary!** 

50 | [get Array[@@species]]41684 "") | **** 
The`**Array[@@species]**`accessor property returns the`Array`constructor. 

51 | [ArrayBuffer]3602 "") | **ArrayBuffer, Web Workers, Worker** 
一个新的拥有指定大小的ArrayBuffer对象。它的内容都被初始化为0。 

52 | [ArrayBuffer.isView()]22967 "") | **** 
The`**ArrayBuffer.isView()**`方法当arg是一个ArrayBuffer的视图就返回true, 例如类型化数组对象([typed array objects]4382 ""))或者 一个数据视图(a[`DataView`]3684 "DataView视图提供了一个与平台中字节在内存中的排列顺序(字节序)无关的从ArrayBuffer读写多数字类型的底层接口."));. 

53 | [ArrayBuffer.prototype]22966 "") | **ArrayBuffer** 
**`ArrayBuffer.prototype`**`属性表示`[`ArrayBuffer`]3602 "一个新的拥有指定大小的ArrayBuffer对象。它的内容都被初始化为0。")对象的原型。 

54 | [ArrayBuffer.prototype.byteLength]22970 "") | **** 
`**byteLength**访问器属性`表示一个[`ArrayBuffer`]3602 "一个新的拥有指定大小的ArrayBuffer对象。它的内容都被初始化为0。")对象的字节长度。 

55 | [ArrayBuffer.prototype.slice()]22969 "") | **** 
`**slice()**`方法返回一个新的`ArrayBuffer`，它的内容是这个`ArrayBuffer的`字节副本，从begin（包括），到end（不包括）。 

56 | [ArrayBuffer.transfer()]22968 "") | **** 
静态`**ArrayBuf**`**fer.transfer()**方法返回一个新的ArrayBuffer， 其内容取自oldBuffer的数据，并且根据 newByteLength 的大小来对数据进行截取或者以0扩展。 如果 newByteLength 未定义，则使用 oldBuffer 的byteLength。这个操作使得 oldBuffer 处于被移除的状态。 

57 | [get ArrayBuffer[@@species]]22965 "") | **ArrayBuffer, JavaScript, TypedArrays, 属性** 
`该**ArrayBuffer[@@species]**`访问器属性会返回`ArrayBuffer`构造器。 

58 | [AsyncFunction]40521 "") | **JavaScript, Reference, async function, 构造函数** 
`**Async**`**`Function`构造函数**创建一个新的[`async function`]40616 "调用 async 函数时会返回一个 Promise 对象。当这个 async 函数返回一个值时，Promise 的 resolve 方法将会处理这个值；当 async 函数抛出异常时，Promise 的 reject 方法将处理这个异常值。")对象。在JavaScript中，每个异步函数实际上都是一个`AsyncFunction`对象。 

59 | [AsyncFunction.prototype]41765 "") | **** 
`**AsyncFunction.prototype**`属性表示[`AsyncFunction`]40521 "AsyncFunction 构造函数 创建一个新的  async function 对象。在JavaScript中，每个异步函数实际上都是一个 AsyncFunction  对象。")的原型对象. 

60 | [Atomics]40522 "") | **** 
**`Atomics`**对象以静态方法的形式提供对{{jsxref(&quot;SharedArrayBuffer&quot;)}} 对象的原子操作。 

61 | [Atomics.add()]41771 "") | **Atomics, JavaScript, Shared Memory, 共享内存, 方法** 
`**Atomics**`**`.add()`**静态方法会将给定的值加到数组里的某个特定位置上，并返回该位置的旧值。此原子操作保证在写上修改的值之前不会发生其他写操作。 

62 | [Atomics.and()]41772 "") | **Atomics, JavaScript, 共享内存, 实验性, 方法** 
`**Atomics**`**`.and()`**静态方法会将给定的值与数组上的值进行按位与操作，并将结果赋值给数组，然后返回数组该位置上的旧值。此原子操作保证在写上修改的值之前不会发生其他写操作。 

63 | [Atomics.compareExchange()]41773 "") | **Atomics, JavaScript, 共享内存, 方法** 
`**Atomics**`**`.compareExchange()`**静态方法会在数组的值与期望值相等的时候，将给定的替换值替换掉数组上的值，然后返回旧值。此原子操作保证在写上修改的值之前不会发生其他写操作。 

64 | [Atomics.exchange()]41774 "") | **Atmoics, Experimental, JavaScript, Method, 共享内存, 实验性** 
`**Atomics**`**`.exchange()`**静态方法会用给定的值替换掉数组上的值，然后返回数组的旧值。此原子操作保证在写上修改的值之前不会发生其他写操作。 

65 | [Atomics.isLockFree()]41775 "") | **** 
静态方法`**Atomics**`**`.isLockFree()`**用于校验是否能够使用原子操作的`[TypedArray]3612 "TypedArray.BYTES_PER_ELEMENT 属性代表了强类型数组中每个元素所占用的字节数。")`的标准字节长度之一. 若该字节长度为可处理的TypedArray标准字节长度之一则返回`true.`TypedArray的标准字节长度参见[BYTES_PER_ELEMENT]22434 "") 

66 | [Atomics.load()]41776 "") | **** 
静态方法`**Atomics**`**`.load()`**返回一个数组当中给定位置的值。 

67 | [Atomics.store()]41779 "") | **** 
静态的Atomics.store（）方法将给定的值存储在数组中的指定位置，并返回该值。. 

68 | [Boolean]40523 "") | **Boolean, Falsy values, Object** 
Boolean 对象是一个布尔值的对象包装器。 

69 | [Boolean.prototype]41810 "") | **** 
**`Boolean.prototype`**属性表示[`Boolean`]40523 "Boolean 对象是一个布尔值的对象包装器。")构造函数的原型。 

70 | [Boolean.prototype.toSource()]41811 "") | **JavaScript, Method, Prototype, 布尔** 
toSource（）方法返回一个表示对象的源码的字符串。 

71 | [Boolean.prototype.toString()]41812 "") | **** 
`**toString()**`方法返回指定的布尔对象的字符串形式。 

72 | [Boolean.prototype.valueOf()]41813 "") | **** 
`**valueOf()**`方法返回一个[`Boolean`]4930 "此页面仍未被本地化, 期待您的翻译!")对象的原始值（primitive value）。 

73 | [DataView]3684 "") | **DataView, JavaScript, 构造器, 结构化数组** 
**`DataView`**视图提供了一个与平台中字节在内存中的排列顺序(字节序)无关的从[`ArrayBuffer`]3602 "一个新的拥有指定大小的ArrayBuffer对象。它的内容都被初始化为0。")读写多数字类型的底层接口. 

74 | [DataView.prototype]41815 "") | **DataView属性** 
`**DataView**`**`.prototype`**表示[`DataView`]3684 "DataView视图提供了一个与平台中字节在内存中的排列顺序(字节序)无关的从ArrayBuffer读写多数字类型的底层接口.")的原型 

75 | [DataView.prototype.buffer]41816 "") | **** 
**`buffer`**属性描述了在构造时被 DataView 引用的[`ArrayBuffer`]3602 "一个新的拥有指定大小的ArrayBuffer对象。它的内容都被初始化为0。")。 

76 | [DataView.prototype.byteLength]41817 "") | **** 
**`byteLength`**属性描述了视图从它的[`ArrayBuffer`]3602 "一个新的拥有指定大小的ArrayBuffer对象。它的内容都被初始化为0。")开始的字节长度。 

77 | [DataView.prototype.byteOffset]41818 "") | **** 
**`byteOffset`**属性描述了从[`ArrayBuffer`]3602 "一个新的拥有指定大小的ArrayBuffer对象。它的内容都被初始化为0。")开始的字节偏移量。 

78 | [DataView.prototype.getFloat32()]41819 "") | **** 
**`getFloat32()`**`方法``从`[`DataView`]3684 "DataView 视图提供了一种用于向 ArrayBuffer 读写数据的底层接口。")起始位置以byte为计数的指定偏移量(byteOffset)处获取一个32-bit数(浮点型). 

79 | [DataView.prototype.getFloat64()]41820 "") | **** 
**`getFloat64()`**`方法``从`[`DataView`]3684 "DataView 视图提供了一种用于向 ArrayBuffer 读写数据的底层接口。")起始位置以byte为计数的指定偏移量(byteOffset)处获取一个64-bit数(双精度浮点型). 

80 | [DataView.prototype.getInt16()]41821 "") | **类型化, 类型化数组** 
**`getInt16()`**`方法``从`[`DataView`]3684 "DataView视图提供了一个与平台中字节在内存中的排列顺序(字节序)无关的从ArrayBuffer读写多数字类型的底层接口.")起始位置以byte为计数的指定偏移量(byteOffset)处获取一个16-bit数(短整型). 

81 | [DataView.prototype.getInt32()]41822 "") | **** 
**`getInt32()`**`方法``从`[`DataView`]3684 "DataView 视图提供了一种用于向 ArrayBuffer 读写数据的底层接口。")起始位置以byte为计数的指定偏移量(byteOffset)处获取一个32-bit数(长整型). 

82 | [DataView.prototype.getInt8()]41823 "") | **类型化, 类型化数组** 
**`getInt8()`**`方法``从`[`DataView`]3684 "DataView视图提供了一个与平台中字节在内存中的排列顺序(字节序)无关的从ArrayBuffer读写多数字类型的底层接口.")起始位置以byte为计数的指定偏移量(byteOffset)处获取一个有符号的8-bit整数(一个字节). 

83 | [DataView.prototype.getUint16()]41824 "") | **类型化, 类型化数组** 
**`getUint16()`**`方法``从`[`DataView`]3684 "DataView 视图提供了一种用于向 ArrayBuffer 读写数据的底层接口。")起始位置以byte为计数的指定偏移量(byteOffset)处获取一个16-bit数(无符号短整型). 

84 | [DataView.prototype.getUint32()]41825 "") | **** 
**`getUint32()`**`方法``从`[`DataView`]3684 "DataView 视图提供了一种用于向 ArrayBuffer 读写数据的底层接口。")起始位置以byte为计数的指定偏移量(byteOffset)处获取一个32-bit数(无符号长整型). 

85 | [DataView.prototype.getUint8()]41826 "") | **类型化, 类型化数组** 
**`getUint8()`**`方法``从`[`DataView`]3684 "DataView视图提供了一个与平台中字节在内存中的排列顺序(字节序)无关的从ArrayBuffer读写多数字类型的底层接口.")起始位置以byte为计数的指定偏移量(byteOffset)处获取一个无符号的8-bit整数(一个字节). 

86 | [DataView.prototype.setFloat32()]41827 "") | **** 
**`setFloat32()`**`从`[`DataView`]3684 "DataView 视图提供了一种用于向 ArrayBuffer 读写数据的底层接口。")起始位置以byte为计数的指定偏移量(byteOffset)处储存一个32-bit数(浮点型). 

87 | [DataView.prototype.setFloat64()]41828 "") | **** 
**`setFloat64()`**`从`[`DataView`]3684 "DataView 视图提供了一种用于向 ArrayBuffer 读写数据的底层接口。")起始位置以byte为计数的指定偏移量(byteOffset)处储存一个64-bit数(双精度浮点型). 

88 | [DataView.prototype.setInt16()]41829 "") | **** 
**`setInt16()`**`从`[`DataView`]3684 "DataView 视图提供了一种用于向 ArrayBuffer 读写数据的底层接口。")起始位置以byte为计数的指定偏移量(byteOffset)处储存一个16-bit数(短整型). 

89 | [DataView.prototype.setInt32()]41830 "") | **** 
**`setInt32()`**`从`[`DataView`]3684 "DataView 视图提供了一种用于向 ArrayBuffer 读写数据的底层接口。")起始位置以byte为计数的指定偏移量(byteOffset)处储存一个32-bit数(长整型). 

90 | [DataView.prototype.setInt8()]41831 "") | **** 
**`setInt8()`**`从`[`DataView`]3684 "DataView 视图提供了一种用于向 ArrayBuffer 读写数据的底层接口。")起始位置以byte为计数的指定偏移量(byteOffset)处储存一个8-bit数(一个字节). 

91 | [DataView.prototype.setUint16()]41832 "") | **** 
**`setUint16()`**`从`[`DataView`]3684 "DataView 视图提供了一种用于向 ArrayBuffer 读写数据的底层接口。")起始位置以byte为计数的指定偏移量(byteOffset)处储存一个16-bit数(无符号短整型). 

92 | [DataView.prototype.setUint32()]41833 "") | **** 
**`setUint32()`**`从`[`DataView`]3684 "DataView 视图提供了一种用于向 ArrayBuffer 读写数据的底层接口。")起始位置以byte为计数的指定偏移量(byteOffset)处储存一个32-bit数(无符号长整型). 

93 | [DataView.prototype.setUint8()]41834 "") | **** 
**`setUint8()`**`从`[`DataView`]3684 "DataView 视图提供了一种用于向 ArrayBuffer 读写数据的底层接口。")起始位置以byte为计数的指定偏移量(byteOffset)处储存一个8-bit数(无符号字节). 

94 | [Date]40524 "") | **Date, JavaScript** 
创建`Date`实例用来处理日期和时间。Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。 

95 | [Date.UTC()]41861 "") | **Date, JavaScript, Method** 
`**Date.UTC()**`方法接受的参数同日期构造函数接受最多参数时一样，返回从1970-1-1 00:00:00 UTC到指定日期的的毫秒数。 

96 | [Date.now()]26870 "") | **Date, JavaScript, Method** 
**`Date.now()`**方法返回自1970年1月1日 00:00:00 UTC到当前时间的毫秒数。 

97 | [Date.parse()]41862 "") | **Date, JavaScript, Method, Reference** 
`**Date.parse()**`方法解析一个表示某个日期的字符串，并返回从1970-1-1 00:00:00 UTC 到该日期对象（该日期对象的UTC时间）的毫秒数，如果该字符串无法识别，或者一些情况下，包含了不合法的日期数值（如：2015-02-31），则返回值为NaN。 

98 | [Date.prototype]41860 "") | **Date, JavaScript, Property** 
**`Date.prototype`**属性表示[`Date`]40524 "创建 Date 实例用来处理日期和时间。Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。")构造函数的原型。 

99 | [Date.prototype.getDate()]41863 "") | **** 
根据本地时间，返回一个指定的日期对象为一个月中的第几天。 

100 | [Date.prototype.getDay()]41864 "") | **** 
**`getDay()`**方法根据本地时间，返回一个具体日期中一周的第几天，0 表示星期天。 

101 | [Date.prototype.getFullYear()]41865 "") | **Date, JavaScript, Method, Prototype, Reference** 
**`getFullYear()`**方法根据本地时间返回指定日期的年份。 

102 | [Date.prototype.getHours()]41866 "") | **** 
**`getHours()`**方法根据本地时间，返回一个指定的日期对象的小时。 

103 | [Date.prototype.getMilliseconds()]41867 "") | **** 
getMilliseconds() 方法，根据本地时间，返回一个指定的日期对象的毫秒数。 

104 | [Date.prototype.getMinutes()]41868 "") | **** 
**`getMinutes()`**方法根据本地时间，返回一个指定的日期对象的分钟数。 

105 | [Date.prototype.getMonth()]41869 "") | **Date, JavaScript, Prototype, 原型, 参考, 方法** 
根据本地时间，返回一个指定的日期对象的月份，为基于0的值（0表示一年中的第一月）。 

106 | [Date.prototype.getSeconds()]41870 "") | **** 
**`getSeconds()`**方法根据本地时间，返回一个指定的日期对象的秒数。 

107 | [Date.prototype.getTime()]41871 "") | **Date, JavaScript, 原型, 方法** 
`**getTime()**`方法返回一个时间的格林威治时间数值。 

108 | [Date.prototype.getTimezoneOffset()]41872 "") | **** 
`**getTimezoneOffset()**`方法返回协调世界时（UTC）相对于当前时区的时间差值，单位为分钟。 

109 | [Date.prototype.getUTCDate()]41873 "") | **** 
**`getUTCDate()`**方法以世界时为标准，返回一个指定的日期对象为一个月中的第几天 

110 | [Date.prototype.getUTCDay()]41874 "") | **** 
**`getUTCDay()`**方法以世界时为标准，返回一个指定的日期对象为一星期中的第几天，其中 0 代表星期天。 

111 | [Date.prototype.getUTCFullYear()]41875 "") | **** 
**`getUTCFullYear()`**以世界时为标准，返回一个指定的日期对象的年份。 

112 | [Date.prototype.getUTCHours()]41876 "") | **** 
**`getUTCHours()`**方法以世界时为标准，返回一个指定的日期对象的小时数。 

113 | [Date.prototype.getUTCMilliseconds()]41877 "") | **** 
**`getUTCMilliseconds()`**方法以世界时为标准，返回一个指定的日期对象的毫秒数。 

114 | [Date.prototype.getUTCMinutes()]41878 "") | **** 
**`getUTCMinutes()`**方法以世界时为标准，返回一个指定的日期对象的分钟数。 

115 | [Date.prototype.getUTCMonth()]41879 "") | **** 
**`getUTCMonth()`**方法以世界时为标准，返回一个指定的日期对象的月份，它是从 0 开始计数的（0 代表一年的第一个月）。 

116 | [Date.prototype.getUTCSeconds()]41880 "") | **** 
**`getUTCSeconds()`**方法以世界时为标准，返回一个指定的日期对象的秒数。 

117 | [Date.prototype.getYear()]41881 "") | **** 
getYear() 方法返回指定的本地日期的年份。因为`getYear`不返回千禧年[full years] (&quot;year 2000 problem&quot;)，所以这个方法不再被使用，现在替换为[`getFullYear`]41865 "getFullYear() 方法根据本地时间返回指定日期的年份。"). 

118 | [Date.prototype.setDate()]41882 "") | **** 
`**setDate()**`方法根据本地时间来指定一个日期对象的天数。 

119 | [Date.prototype.setFullYear()]41883 "") | **** 
`**setFullYear()**`方法根据本地时间为一个日期对象设置年份。 

120 | [Date.prototype.setHours()]41884 "") | **** 
`**setHours()**`方法根据本地时间为一个日期对象设置小时数，返回从1970-01-01 00:00:00 UTC 到更新后的[`日期`]40524 "创建 Date 实例用来处理日期和时间。Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。")对象实例所表示时间的毫秒数。 

121 | [Date.prototype.setMilliseconds()]41885 "") | **** 
`**setMilliseconds()**`方法会根据本地时间设置一个日期对象的豪秒数。 

122 | [Date.prototype.setMinutes()]41886 "") | **** 
`**setMinutes()**`方法根据本地时间为一个日期对象设置分钟数。 

123 | [Date.prototype.setMonth()]41887 "") | **** 
`**setMonth()**`方法根据本地时间为一个设置年份的日期对象设置月份。 

124 | [Date.prototype.setSeconds()]41888 "") | **** 
`**setSeconds()**`方法根据本地时间设置一个日期对象的秒数。 

125 | [Date.prototype.setTime()]41889 "") | **** 
`**setTime()**`方法以一个表示从1970-1-1 00:00:00 UTC计时的毫秒数为来为`Date`对象设置时间。 

126 | [Date.prototype.setUTCDate()]41890 "") | **** 
**`setUTCDate()`**方法就是根据全球时间设置特定date对象的日期。 

127 | [Date.prototype.setUTCFullYear()]41891 "") | **Date, JavaScript, Method, Prototype, Reference** 
**`setUTCFullYear()`**方法根据世界标准时间为一个具体日期设置年份。 

128 | [Date.prototype.setUTCHours()]41892 "") | **** 
The**`setUTCHours()`**method sets the hour for a specified date according to universal time, and returns the number of milliseconds since 1 January 1970 00:00:00 UTC until the time represented by the updated[`Date`]12702 "此页面仍未被本地化, 期待您的翻译!")instance. 

129 | [Date.prototype.setUTCMilliseconds()]41893 "") | **** 
**`setUTCMilliseconds()`**方法会根据世界时来设置指定时间的毫秒数。 

130 | [Date.prototype.setUTCMonth()]41895 "") | **** 
**`setUTCMonth()方法根据通用的时间来设置一个准确的月份`** 

131 | [Date.prototype.setUTCSeconds()]41896 "") | **日期** 
`**setUTCSeconds()**`方法为一个依据国际通用时间的特定日期设置秒数。 

132 | [Date.prototype.setYear()]41897 "") | **** 
The`**setYear()**`method sets the year for a specified date according to local time. Because`setYear`does not set full years (&quot;year 2000 problem&quot;), it is no longer used and has been replaced by the[`setFullYear`]41883 "setFullYear() 方法根据本地时间为一个日期对象设置年份。")method. 

133 | [Date.prototype.toDateString()]41898 "") | **** 
`**toDateString()**`方法以美式英语和人类易读的形式返回一个日期对象日期部分的字符串。 

134 | [Date.prototype.toGMTString()]41899 "") | **** 
The`**toGMTString()**`method converts a date to a string, using Internet GMT conventions. The exact format of the value returned by`toGMTString`varies according to the platform and browser, in general it should represent a human readable date string. 

135 | [Date.prototype.toISOString()]41900 "") | **** 
`**toISOString()**`方法返回一个 ISO（[ISO 8601 Extended Format]44198 "")）格式的字符串：**YYYY-MM-DDTHH:mm:ss.sssZ**。时区总是UTC（协调世界时），加一个后缀“Z”标识。 

136 | [Date.prototype.toJSON()]41901 "") | **** 
**`toJSON()`**方法返回[`Date`]12702 "此页面仍未被本地化, 期待您的翻译!")对象的字符串形式。 

137 | [Date.prototype.toLocaleDateString()]41902 "") | **** 
`**toLocaleDateString()**`方法返回该日期对象日期部分的字符串，该字符串格式因不同语言而不同。新增的参数`locales`和`options`使程序能够指定使用哪种语言格式化规则，允许定制该方法的表现（behavior）。在旧版本浏览器中，`locales`和`options`参数被忽略，使用的语言环境和返回的字符串格式是各自独立实现的。 

138 | [Date.prototype.toLocaleFormat()]41903 "") | **Date, 非标准** 
非标准方法**`toLocaleFormat()`**按特定的格式将一个日期转换成一个字符串。[`Intl.DateTimeFormat`]40532 "DateTimeFormat实例集成以下原型的属性:")是符合标准的格式化日期的替代方法。另见更新的(newer)版本的[`Date.prototype.toLocaleDateString()`]41902 "toLocaleDateString() 方法返回该日期对象日期部分的字符串，该字符串格式因不同语言而不同。新增的参数 locales 和 options 使程序能够指定使用哪种语言格式化规则，允许定制该方法的表现（behavior）。在旧版本浏览器中， locales 和 options 参数被忽略，使用的语言环境和返回的字符串格式是各自独立实现的。")方法. 

139 | [Date.prototype.toLocaleString()]41904 "") | **** 
`**toLocaleString()**`方法返回该日期对象的字符串，该字符串格式因不同语言而不同。新增的参数`locales`和`options`使程序能够指定使用哪种语言格式化规则，允许定制该方法的表现（behavior）。在旧版本浏览器中，`locales`和`options`参数被忽略，使用的语言环境和返回的字符串格式是各自独立实现的。 

140 | [Date.prototype.toLocaleTimeString()]41905 "") | **** 
The`**toLocaleTimeString()**`方法返回该日期对象时间部分的字符串，该字符串格式因不同语言而不同。新增的参数`locales`和`options`使程序能够指定使用哪种语言格式化规则，允许定制该方法的表现（behavior）。在旧版本浏览器中，`locales`和`options`参数被忽略，使用的语言环境和返回的字符串格式是各自独立实现的。 

141 | [Date.prototype.toString()]41907 "") | **** 
`**toString()**`方法返回一个字符串，表示该[`Date`]12702 "此页面仍未被本地化, 期待您的翻译!")对象。 

142 | [Date.prototype.toTimeString()]41908 "") | **** 
`**toTimeString()**`方法以人类易读形式返回一个日期对象时间部分的字符串，该字符串以美式英语格式化。 

143 | [Date.prototype.toUTCString()]41909 "") | **** 
`**toUTCString()**`方法把一个日期转换为一个字符串，使用UTC时区。 

144 | [Date.prototype.valueOf()]41910 "") | **Date, JavaScript, 原型, 参考, 方法, 日期** 
`**valueOf()**`方法返回一个[`Date`]12702 "此页面仍未被本地化, 期待您的翻译!")对象的原始值。 

145 | [Error]10494 "") | **);, Error, Whoops!, throw new Error(, 参考** 
通过**Error**的构造器可以创建一个错误对象。当运行时错误产生时，Error的实例对象会被抛出。Error对象可用于用户自定义的异常的基础对象。下面列出了各种内建的标准错误类型。 

146 | [Error.prototype]41983 "") | **Error, JavaScript, Property, 参考, 属性** 
所有[`Error`]10494 "通过Error的构造器可以创建一个错误对象。当运行时错误产生时，Error的实例对象会被抛出。Error对象可用于用户自定义的异常的基础对象。下面列出了各种内建的标准错误类型。")与[非标准Error](%10494#Error_types "通过Error的构造器可以创建一个错误对象。当运行时错误产生时，Error的实例对象会被抛出。Error对象可用于用户自定义的异常的基础对象。下面列出了各种内建的标准错误类型。")的实例都继承自`Error.prototype。同所有构造器函数一样，你可以在构造器的`prototype 上添加属性或者方法，使其在所有该构造器的实例上生效。 

147 | [Error.prototype.columnNumber]41984 "") | **** 
`**columnNumber**`属性包含引发此错误的文件行中的列号。 

148 | [Error.prototype.fileName]41985 "") | **** 
`**fileName**`属性包含引发此错误的文件的路径. 

149 | [Error.prototype.message]41987 "") | **** 
`**message**`属性是有关错误信息，人类易读的（human-readable）描述。 

150 | [Error.prototype.name]41988 "") | **** 
`**name**`属性表示error类型的名称.初始值为&quot;Error&quot;. 

151 | [Error.prototype.toString()]41992 "") | **** 
`**toString()**`方法返回一个指定的错误对象（Error object）的字符串表示。 

152 | [EvalError]40525 "") | **** 
本对象代表了一个关于[eval]42009 "en/Core_JavaScript_1.5_Reference/Global_Functions/eval")函数的错误.此异常不再会被JavaScript抛出，但是EvalError对象仍然保持兼容性. 

153 | [Float32Array]3610 "") | **JavaScript, TypeArray, TypeArrays, 构造函数** 
**`Float32Array`**类型数组代表的是平台字节顺序为32位的浮点数型数组(对应于 C 浮点数据类型) 。 如果需要控制字节顺序， 使用[`DataView`]3684 "DataView视图提供了一个与平台中字节在内存中的排列顺序(字节序)无关的从ArrayBuffer读写多数字类型的底层接口.")替代。其内容初始化为`0`。一旦建立起来，你可以使用这个对象的方法对其元素进行操作，或者使用标准数组索引语法 (使用方括号)。 

154 | [Float64Array]3611 "") | **JavaScript, TypeArray, TypeArrays, 构造函数** 
**`Float64Array`**类型数组代表的是平台字节顺序为64位的浮点数型数组(对应于 C 浮点数据类型) 。 如果需要控制字节顺序， 使用[`DataView`]3684 "DataView视图提供了一个与平台中字节在内存中的排列顺序(字节序)无关的从ArrayBuffer读写多数字类型的底层接口.")替代。其内容初始化为`0`。一旦建立起来，你可以使用这个对象的方法对其元素进行操作，或者使用标准数组索引语法 (使用方括号)。 

155 | [Function]40526 "") | **CSP, Constructor, Function, JavaScript, 函数, 构造器** 
**`Function`构造函数**创建一个新的Function对象。 在 JavaScript 中, 每个函数实际上都是一个`Function对象。` 

156 | [Function.arguments]41685 "") | **** 
`***function*.arguments**`属性代表传入函数的实参，它是一个类数组对象。 

157 | [Function.arity]41686 "") | **** 
返回一个函数的形参数量. 

158 | [Function.caller]41687 "") | **** 
返回调用指定函数的函数. 

159 | [Function.displayName]41688 "") | **** 
`***function*.displayName属性获取函数的显示名称**` 

160 | [Function.length]41689 "") | **Function, JavaScript, Property** 
**No summary!** 

161 | [Function.name]41690 "") | **ECMAScript 2015, Function, JavaScript, Property** 
`name`属性返回一个函数声明的名称。 

162 | [Function.prototype]41691 "") | **JavaScript, 函数, 原型, 原型属性** 
`**Function.prototype**`属性存储了[`Function`]40772 "此页面仍未被本地化, 期待您的翻译!")的原型对象。 

163 | [Function.prototype.apply()]41200 "") | **Function, Function.prototype.apply(), JavaScript, Method, apply(), bind(), call()** 
**`apply()`**方法调用一个函数, 其具有一个指定的`this`值，以及作为一个数组（或[类似数组的对象]41484 "")）提供的参数。 

164 | [Function.prototype.bind()]41204 "") | **JavaScript, bind(), polyfill, 函数** 
**bind()**方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 

165 | [Function.prototype.call()]41479 "") | **JavaScript, apply(), bind(), call(), this, 函数, 方法** 
`**call()**`方法调用一个函数, 其具有一个指定的`this`值和分别地提供的参数(**参数的列表**)。 

166 | [Function.prototype.isGenerator()]41692 "") | **** 
判断一个函数是否是一个[生成器]44200 "zh-cn/Core JavaScript 1.5 Guide/Iterators and Generators#Generators.3a a better way to build Iterators"). 

167 | [Function.prototype.toSource()]41693 "") | **** 
返回函数的源代码的字符串表示. 

168 | [Function.prototype.toString()]41694 "") | **** 
该`toString()`方法返回一个表示当前函数源代码的字符串。 

169 | [Generator]40527 "") | **ECMAScript 2015, Generator, JavaScript, 参考, 生成器** 
**生成器**对象是由一个[generator function]40631 "function* 这种声明方式(function关键字后跟一个星号）会定义一个生成器函数 (generator function)，它返回一个  Generator  对象。")返回的,并且它符合[可迭代协议]42029 "")和[迭代器协议]42030 "")。 

170 | [Generator.prototype.next()]41437 "") | **ECMAScript 2015, Generator, JavaScript, 原型, 参考, 方法, 生成器** 
`**next**`**`()`**方法返回一个包含属性`done`和`value`的对象。该方法也可以通过接受一个参数用以向生成器传值。 

171 | [Generator.prototype.return()]41439 "") | **ECMAScript6, JavaScript, 原型, 参考, 方法, 生成器** 
`**return**`**`()`**方法返回给定的值并结束生成器。 

172 | [Generator.prototype.throw()]41438 "") | **ECMAScript6, JavaScript, 参考, 属性, 方法, 生成器** 
`**throw**`**`()`**方法用来向生成器抛出异常，并恢复生成器的执行，返回带有`done`及`value`两个属性的对象。 

173 | [GeneratorFunction]43174 "") | **Constructor, ECMAScript 2015, GeneratorFunction, Iterator, JavaScript, Reference** 
**`GeneratorFunction`构造器**生成新的[`生成器函数`]40631 "function* 这种声明方式(function关键字后跟一个星号）会定义一个生成器函数 (generator function)，它返回一个  Generator  对象。")对象。在JavaScript中，生成器函数实际上都是`GeneratorFunction`的实例对象。 

174 | [GeneratorFunction.prototype]44201 "") | **ECMAScript 2015, GeneratorFunction, Iterator, JavaScript, Property, Prototype, Reference** 
`**GeneratorFunction.prototype**`属性是[`GeneratorFunction`]44202 "此页面仍未被本地化, 期待您的翻译!")的原型对象。 

175 | [Infinity]23641 "") | **JavaScript** 
全局属性`**Infinity**`是一个数值，表示无穷大。 

176 | [Int16Array]3606 "") | **** 
The**`Int16Array`**typed array represents an array of twos-complement 16-bit signed integers in the platform byte order. If control over byte order is needed, use[`DataView`]3684 "DataView视图提供了一个与平台中字节在内存中的排列顺序(字节序)无关的从ArrayBuffer读写多数字类型的底层接口.")instead. The contents are initialized to`0`. Once established, you can reference elements in the array using the object&#39;s methods, or using standard array index syntax (that is, using bracket notation). 

177 | [Int32Array]3608 "") | **** 
The**`Int32Array`**typed array represents an array of twos-complement 32-bit signed integers in the platform byte order. If control over byte order is needed, use[`DataView`]3684 "DataView视图提供了一个与平台中字节在内存中的排列顺序(字节序)无关的从ArrayBuffer读写多数字类型的底层接口.")instead. The contents are initialized to`0`. Once established, you can reference elements in the array using the object&#39;s methods, or using standard array index syntax (that is, using bracket notation). 

178 | [Int8Array]3604 "") | **Int8Array, 构造器, 特定类型数组** 
**`Int8Array`**类型数组表示二进制补码8位有符号整数的数组。内容初始化为0。 一旦建立，你可以使用对象的方法引用数组中的元素，或使用标准数组索引语法( 即，使用括号注释)。 

179 | [InternalError]40529 "") | **InternalError, 内部错误** 
**`InternalError`对象**表示出现在JavaScript引擎内部的错误。 例如：**&quot;InternalError**: too much recursion&quot;（内部错误：递归过深）。 

180 | [Intl]40530 "") | **JavaScript, 国际化** 
国际化的构造函数和其他构造函数的几个语言敏感的方法（可见[See also]44203 "")）一样，使用同样的模式来识别语言区域和确定使用哪一种语言格式：他们都接收 locales 和 options 参数，使用 options.localeMatcher 属性指定的一个算法来对比应用请求的和支持的语言区域，来确定使用哪一个语言区域。 

181 | [Intl.Collator]40531 "") | **** 
**`Intl.Collator`**`是用于语言敏感字符串比较的 collators构造函数。` 

182 | [Intl.DateTimeFormat]40532 "") | **** 
`DateTimeFormat实例集成以下原型的属性`: 

183 | [Intl.DateTimeFormat.prototype]42096 "") | **** 
**`Intl.DateTimeFormat.prototype`**表示[`Intl.DateTimeFormat`]40532 "DateTimeFormat实例集成以下原型的属性:")构造函数的原型对象。 

184 | [Intl.NumberFormat]40533 "") | **** 
**`Intl.NumberFormat是对语言敏感的格式化数字类的构造器类`** 

185 | [Iterator]43553 "") | **Deprecated** 
`**Iterator**`函数返回一个对象，它实现了遗留的迭代协议，并且迭代了一个对象的可枚举属性。 

186 | [JSON]4311 "") | **JSON, JavaScript, Object, Reference, polyfill** 
**`JSON`**对象包含用于解析[JavaScript Object Notation]42150 "")([JSON]16796 "JSON: The JavaScript Object Notation (JSON) is a data-interchange format.  Although not a strict subset, JSON closely resembles a subset of JavaScript syntax. Though many programming languages support JSON, JSON is especially useful for JavaScript-based apps, including websites and browser extensions.")) 的方法，并将值转换为 JSON。它不能被调用或者作为构造函数，除了它的两个方法属性，它本身并没有有趣的功能。 

187 | [JSON.parse()]42149 "") | **ECMAScript5, JSON, JSON.parse(), JSON.stringify, JavaScript, 方法** 
`**JSON.parse()**`方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)。 

188 | [JSON.stringify()]16630 "") | **JSON, JSON.stringify(), JavaScript, Method, Reference, stringify, 字符串** 
`**JSON.stringify()**`方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，如果指定了replacer是一个函数，则可以替换值，或者如果指定了replacer是一个数组，可选的仅包括指定的属性。 

189 | [Map]40535 "") | **ECMAScript6, JavaScript, Map** 
**`Map`**对象保存键值对。任何值(对象或者[原始值]41155 "原始值: A primitive (primitive value, primitive data type) is data that is not an object and has no methods. In JavaScript, there are 6 primitive data types: string, number, boolean, null, undefined, symbol (new in ECMAScript 2015).")) 都可以作为一个键或一个值。 

190 | [Map.prototype]42166 "") | **** 
`**Map**`**`.prototype`**属性表示[`Map`]40774 "此页面仍未被本地化, 期待您的翻译!")构造函数的原型对象。 

191 | [Map.prototype.clear()]42170 "") | **** 
clear()方法会移除Map对象中的所有元素。 

192 | [Map.prototype.delete()]42171 "") | **** 
****`****delete()****`****方法用于移除`Map`对象中指定的元素。 

193 | [Map.prototype.entries()]42172 "") | **** 
`**entries()**`?方法返回一个新的包含`[key, value]`?对的`**Iterator**`?对象，返回的迭代器的迭代顺序与`Map`对象的插入顺序相同。 

194 | [Map.prototype.forEach()]42173 "") | **** 
`**forEach()**`?方法将会以插入顺序对 Map 对象中的每一个键值对执行一次参数中提供的回调函数。 

195 | [Map.prototype.get()]42174 "") | **** 
`**get()**`方法用来获取一个`Map`?对象中指定的元素。 

196 | [Map.prototype.has()]42175 "") | **** 
方法`**has()**`返回一个bool值，用来表明map 中是否存在指定元素. 

197 | [Map.prototype.keys()]42176 "") | **ECMAScript6, Iteraotr, JavaScript, Map, Method, Prototype** 
`**keys()**`返回一个新的`**Iterator**`对象。它包含按照顺序插入Map对象中每个元素的key值。 

198 | [Map.prototype.set()]42177 "") | **ECMAScript6, JavaScript, Map, Method, Prototype** 
**No summary!** 

199 | [Map.prototype.size]42167 "") | **** 
`**size**`可访问属性返回[`Map`]40774 "此页面仍未被本地化, 期待您的翻译!")对象的元素数量. 

200 | [Map.prototype.values()]42178 "") | **** 
一个新的[`Map`]40774 "此页面仍未被本地化, 期待您的翻译!")可迭代对象. 

201 | [Map.prototype[@@iterator]()]42179 "") | **** 
**No summary!** 

202 | [Map.prototype[@@toStringTag]]42168 "") | **** 
**`Map[@@toStringTag]`**的初始值是&quot;Map&quot;. 

203 | [get Map[@@species]]42169 "") | **** 
`**Map[@@species]**`访问器属性会返回一个`Map`构造函数. 

204 | [Math]40536 "") | **JavaScript, Math, NeedsTranslation, TopicStub** 
**`Math`**是一个内置对象， 它具有数学常数和函数的属性和方法。不是一个函数对象。 

205 | [Math.E]42186 "") | **** 
`**Math.E**`属性表示自然对数的底数（或称为基数），e，约等于 2.718。 

206 | [Math.LN10]42187 "") | **** 
`**Math.LN10**`属性表示 10 的自然对数，约为 2.302： 

207 | [Math.LN2]42188 "") | **** 
`**Math.LN2**`属性表示 2 的自然对数，约为 0.693： 

208 | [Math.LOG10E]42189 "") | **** 
`**Math.LOG10E**`属性表示以 10 为底数，e 的对数，约为 0.434： 

209 | [Math.LOG2E]42190 "") | **** 
`**Math.LOG2E**`属性表示以 2 为底数，e 的对数，约为 1.442： 

210 | [Math.PI]42191 "") | **** 
`**Math.PI**`表示一个圆的周长与直径的比例，约为 3.14159： 

211 | [Math.SQRT1_2]42192 "") | **** 
`**Math.SQRT1_2**`属性表示 1/2 的平方根，约为 0.707： 

212 | [Math.SQRT2]42193 "") | **** 
`**Math.SQRT2**`属性表示 2 的平方根，约为 1.414： 

213 | [Math.abs()]41268 "") | **** 
`**Math.abs(x)**`函数返回指定数字 “x“ 的绝对值。如下： 

214 | [Math.acos()]41273 "") | **** 
`**Math.acos()**`返回一个数的反余弦值（单位为弧度），即： 

215 | [Math.acosh()]42194 "") | **三角函数, 数学** 
**`Math.acosh()`**`返回一个数字的反双曲余弦值，即：` 

216 | [Math.asin()]41272 "") | **** 
`**Math.asin()**`方法返回一个数值的反正弦（单位为弧度），即： 

217 | [Math.asinh()]41279 "") | **** 
**`Math.asinh()`**函数返回给定数字的反双曲正弦值, 即： 

218 | [Math.atan()]41274 "") | **** 
`**Math.atan()**`函数返回一个数值的反正切（以弧度为单位），即： 

219 | [Math.atan2()]41275 "") | **** 
`**Math.atan2()**`返回其参数比值的反正切值。 

220 | [Math.atanh()]41281 "") | **** 
**`Math.atanh()`**函数返回一个数值反双曲正切值, 即： 

221 | [Math.cbrt()]41295 "") | **** 
`**Math.cbrt()**`函数返回任意数字的立方根. 

222 | [Math.ceil()]41288 "") | **Math.ceil(), Math.ceil() === 向上取整, 向上取整** 
**`Math.ceil()`**函数返回大于或等于一个给定数字的最小整数。 

223 | [Math.clz32()]41298 "") | **** 
`**Math.clz32()**`函数返回一个数字在转换成 32 无符号整形数字的二进制形式后, 开头的 0 的个数, 比如`1000000`转换成 32 位无符号整形数字的二进制形式后是`00000000000011110100001001000000`, 开头的 0 的个数是 12 个, 则`Math.clz32(1000000)`返回`12`. 

224 | [Math.cos()]41270 "") | **** 
`**Math.cos()**`函数返回一个数值的余弦值。 

225 | [Math.cosh()]41277 "") | **** 
**`Math.cosh()`**函数返回数值的双曲余弦函数, 可用[constant e]42186 "Math.E 属性表示自然对数的底数（或称为基数），e，约等于 2.718。")表示: 

226 | [Math.exp()]41283 "") | **** 
`**Math.exp()**`函数返回`e<sup>x</sup>`，`x`表示参数，`e`是[欧拉常数（Euler&#39;s constant）]42186 "")，自然对数的底数。 

227 | [Math.expm1()]41284 "") | **** 
`**Math.expm1()**`函数返回`E<sup>x</sup>- 1`, 其中`x`是该函数的参数,`E`是自然对数的底数`2.718281828459045.` 

228 | [Math.floor()]407 "") | **Math.floor(), 向下取整** 
`**Math.floor()**`返回小于或等于一个给定数字的最大整数。 

229 | [Math.fround()]41292 "") | **** 
**`Math.fround()`**可以将任意的数字转换为离它最近的[单精度浮点数]44204 "link to the wikipedia page on single-precision floating-point format")形式的数字。 

230 | [Math.hypot()]41296 "") | **JavaScript, Math, 方法, 试验性** 
`**Math.hypot()**`函数返回它的所有参数的平方和的平方根，即： 

231 | [Math.imul()]41299 "") | **** 
该函数返回两个参数的类C的32位整数乘法运算的运算结果. 

232 | [Math.log()]42195 "") | **** 
`**Math.log()**`函数返回一个数的自然对数，即： 

233 | [Math.log10()]41285 "") | **** 
`**Math.log10()**`函数返回一个数字以 10 为底的对数. 

234 | [Math.log1p()]41286 "") | **** 
`**Math.log1p()**`函数返回一个数字加1后的自然对数 (底为`E`), 既`log(x+1)`. 

235 | [Math.log2()]41287 "") | **** 
`**Math.log2()**`函数返回一个数字以 2 为底的对数. 

236 | [Math.max()]41290 "") | **JavaScript, Math, 方法** 
`**Math.max()**`函数返回一组数中的最大值。 

237 | [Math.min()]41289 "") | **JavaScript, Math, Math.min, 参考, 方法** 
`**Math.min()**`返回零个或更多个数值的最小值。 

238 | [Math.pow()]41282 "") | **** 
`**Math.pow()**`函数返回基数（`base`）的指数（`exponent`）次幂`，即``base<sup>exponent</sup>`。 

239 | [Math.random()]24023 "") | **JavaScript, Math, Math.random(), Method, 随机数** 
`**Math.random()**`函数返回一个浮点, 伪随机数在范围**[0，1)**，也就是说，从0（包括0）往上，但是不包括1（排除1），然后您可以缩放到所需的范围。实现将初始种子选择到随机数生成算法;它不能被用户选择或重置。他不能被用户选择或重置。 

240 | [Math.round()]41291 "") | **Math.round(), 四舍五入** 
`**Math.round()**`函数返回一个数字四舍五入后最接近的整数值。 

241 | [Math.sign()]41297 "") | **JavaScript, Math, Math.sign()** 
**`Math.sign()`**函数返回一个数字的符号, 指示数字是正数，负数还是零。 

242 | [Math.sin()]41269 "") | **** 
`**Math.sin()**`函数返回一个数值的正弦值。 

243 | [Math.sinh()]41276 "") | **** 
`**Math.sinh()**`函数返回一个数字(单位为角度)的双曲正弦值. 

244 | [Math.sqrt()]41294 "") | **** 
`**Math.sqrt()**`函数返回一个数的平方根，即： 

245 | [Math.tan()]41271 "") | **** 
`**Math.tan()**`方法返回一个数值的正切值。 

246 | [Math.tanh()]41278 "") | **ECMAScript6, JavaScript, Math, Method, tanh, 双曲正切** 
**`Math.tanh()`**函数将会返回一个数的双曲正切函数值，计算如下: 

247 | [Math.trunc()]41293 "") | **ECMAScript 2015, JavaScript, Math, Method** 
`**Math.trunc()**`方法会将数字的小数部分去掉，只保留整数部分。 

248 | [NaN]23642 "") | **NaN** 
全局属性**`NaN`**表示 Not-A-Number 的值。 

249 | [Number]10157 "") | **JavaScript, Number, Reference** 
JavaScript 的**`Number`**对象是经过封装的能让你处理数字值的对象。`Number`对象由`Number()`构造器创建。 

250 | [Number.EPSILON]41258 "") | **** 
**`Number.EPSILON`**属性表示 1 和大于 1 的最小值（可表示为[`Number`]10157 "JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。Number 对象由 Number() 构造器创建。")）的差值。 

251 | [Number.MAX_SAFE_INTEGER]22961 "") | **** 
**`Number.MAX_SAFE_INTEGER`**常量表示在 JavaScript 中最大的安全整数（maxinum safe integer)（`2<sup>53</sup>- 1）。` 

252 | [Number.MAX_VALUE]41253 "") | **** 
`**Number.MAX_VALUE**`属性表示在 JavaScript 里所能表示的最大数值。 

253 | [Number.MIN_SAFE_INTEGER]41259 "") | **** 
**`Number.MIN_SAFE_INTEGER`**代表在 JavaScript中最小的安全的integer型数字 (`-(2<sup>53</sup>- 1)`). 

254 | [Number.MIN_VALUE]41254 "") | **** 
`**Number.MIN_VALUE**`属性表示在 JavaScript 中所能表示的最小的正值。 

255 | [Number.NEGATIVE_INFINITY]41256 "") | **** 
`**Number.NEGATIVE_INFINITY**`属性表示负无穷大。 

256 | [Number.NaN]41255 "") | **** 
`**Number.NaN**`表示“非数字”（Not-A-Number）。和[`NaN`]23642 "全局属性 NaN 表示 Not-A-Number 的值。")相同。 

257 | [Number.POSITIVE_INFINITY]41257 "") | **** 
`**Number.POSITIVE_INFINITY**`属性表示正无穷大。 

258 | [Number.isFinite()]41262 "") | **Experimental, Expérimental(2), JavaScript, Method, Number, Reference, Référence(2)** 
**`Number.isFinite()`**方法用来检测传入的参数是否是一个有穷数（finite number）。 

259 | [Number.isInteger()]41263 "") | **JavaScript, Method, Number, Reference, 方法** 
**`Number.isInteger()`**方法用来判断给定的参数是否为整数。 

260 | [Number.isNaN()]41206 "") | **ECMAScript6, Experimental, Expérimental(2), JavaScript, Method, Number** 
**`Number.isNaN()`**方法确定传递的值是否为[`NaN`]23642 "全局属性 NaN 表示 Not-A-Number 的值。")和其类型是[`Number`]10157 "JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。Number 对象由 Number() 构造器创建。")。它是原始的全局[`isNaN()`]40575 "isNaN() 函数用来确定一个值是否为NaN 。注：isNaN函数内包含一些非常有趣的规则；你也可以通过ECMAScript 2015/ES6 中定义的Number.isNaN()或者 可以使用typeof 来判断该值是否为一个非数字。")的更强大的版本。 

261 | [Number.isSafeInteger()]41264 "") | **** 
**`Number.isSafeInteger()`**方法用来判断传入的参数值是否是一个“安全整数”（safe integer）。一个安全整数是一个符合下面条件的整数： 

262 | [Number.parseFloat()]41260 "") | **** 
**`Number.parseFloat()`**方法可以把一个字符串解析成浮点数。该方法与全局的[`parseFloat()`]40576 "parseFloat() 函数解析一个字符串参数并返回一个浮点数。")函数相同，并且处于 ECMAScript 6 规范中（用于全局变量的模块化）。 

263 | [Number.parseInt()]41261 "") | **ECMAScript 2015, JavaScript, Method, Number** 
**`Number.parseInt()`**方法可以根据给定的进制数把一个字符串解析成整数。 

264 | [Number.prototype]42209 "") | **** 
**`Number.prototype`**属性表示[`Number`]10157 "Number JavaScript 对象是一个允许你处理数字值的包装对象。Number 对象使用 Number() 构造器创建。")构造函数的原型。 

265 | [Number.prototype.toExponential()]41265 "") | **** 
**`toExponential()`**方法以指数表示法返回该数值字符串表示形式。 

266 | [Number.prototype.toFixed()]41266 "") | **** 
`**toFixed()**`方法使用定点表示法来格式化一个数。 

267 | [Number.prototype.toLocaleString()]42069 "") | **JavaScript, 原型, 国际化, 数字, 方法** 
`**toLocaleString()**`方法返回这个数字在特定语言环境下的表示字符串。 

268 | [Number.prototype.toPrecision()]41267 "") | **** 
`**toPrecision()**`方法以指定的精度返回该数值对象的字符串表示。 

269 | [Number.prototype.toSource()]42210 "") | **** 
`**toSource()**`方法返回该对象源码的字符串表示。 

270 | [Number.prototype.toString()]42211 "") | **** 
**`toString()`**方法返回指定[`Number`]10157 "JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。Number 对象由 Number() 构造器创建。")对象的字符串表示形式。 

271 | [Number.prototype.valueOf()]42212 "") | **JavaScript, Method, Number** 
**`valueOf()`**方法返回一个被[`Number`]10157 "JavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。Number 对象由 Number() 构造器创建。")对象包装的原始值。 

272 | [Number.toInteger()]42213 "") | **** 
**`Number.toInteger()`**用来将参数转换成整数,但该方法的实现已被移除. 

273 | [Object]10219 "") | **JavaScript, Object, 对象, 构造器** 
`**Object**`构造函数创建一个对象包装器。 

274 | [Object.assign()]42226 "") | **ECMAScript 2015, JavaScript, Method, Object, polyfill** 
`**Object.assign()**`方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 

275 | [Object.create()]41405 "") | **ECMAScript5, JavaScript, Method, Object, Reference, polyfill** 
**`Object.create()`**方法会使用指定的原型对象及其属性去创建一个新的对象。 

276 | [Object.defineProperties()]42227 "") | **ECMAScript 5, JavaScript, Method, Object** 
**`Object.defineProperties()`**方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。 

277 | [Object.defineProperty()]41461 "") | **ECMAScript 5, JavaScript, JavaScript 1.8.5, Method, Object** 
`**Object.defineProperty()**`方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 

278 | [Object.defineProperty 的补充示例]44205 "") | **Examples, JavaScript, Object** 
本页为[`Object.defineProperty()`]41461 "Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。")提供一个附加示例。 

279 | [Object.entries()]42228 "") | **JavaScript, Method, Object, Object.entries(), Reference, 对象, 方法** 
`Object.entries()`返回一个数组，其元素是与直接在`object`上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。 

280 | [Object.freeze()]42229 "") | **ECMAScript 5, JavaScript, Method, Object** 
**`Object.freeze()`**方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。 

281 | [Object.getNotifier()]42230 "") | **** 
**`Object.getNotifer()`**方法用于创建可人工触发 change 事件的对象，但该方法在浏览器中已被废弃。 

282 | [Object.getOwnPropertyDescriptor()]41458 "") | **JavaScript, Object, 对象, 方法** 
**`Object.getOwnPropertyDescriptor()`**方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性） 

283 | [Object.getOwnPropertyDescriptors()]42231 "") | **** 
`**Object.getOwnPropertyDescriptors()**`方法用来获取一个对象的所有自身属性的描述符。 

284 | [Object.getOwnPropertyNames()]41474 "") | **ECMAScript 5, JavaScript, JavaScript 1.8.5, Method, Object, Reference** 
**`Object.getOwnPropertyNames()`**方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。 

285 | [Object.getOwnPropertySymbols()]41475 "") | **ECMAScript 2015, JavaScript, Method, Object** 
`**Object.getOwnPropertySymbols()**`方法返回一个给定对象自身的所有 Symbol 属性的数组。 

286 | [Object.getPrototypeOf()]42232 "") | **ECMAScript 5, JavaScript, Method, Object** 
`**Object.getPrototypeOf()**`方法返回指定对象的原型（内部`[[Prototype]]`属性的值）。 

287 | [Object.is()]40770 "") | **Comparison, Condition, Conditional, ECMAScript 2015, Equality, JavaScript, Method, Object** 
`**Object.is()**`方法判断两个值是否是[相同的值]40512 "")。 

288 | [Object.isExtensible()]41452 "") | **** 
`**Object.isExtensible()**`方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。 

289 | [Object.isFrozen()]42233 "") | **ECMAScript 5, JavaScript, JavaScript 1.8.5, Method, Object** 
`**Object.isFrozen()**`方法判断一个对象是否被[冻结]42229 "Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。")。 

290 | [Object.isSealed()]42234 "") | **ECMAScript5, JavaScript, Method, Object** 
**`Object.isSealed()`**方法判断一个对象是否被密封。 

291 | [Object.keys()]41476 "") | **CCAC: Chrome Console Auto Copy, ECMAScript 5, JavaScript, Method, Object** 
**Object.keys()**方法会返回一个由一个给定**对象**的自身可枚举属性组成的**数组**，数组中属性名的排列顺序和使用[`for...in`]40629 "for...in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。")循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。 

292 | [Object.observe()]42235 "") | **ECMAScript7, Experimental, Expérimental, JavaScript, Method, Object, observe** 
**`Object.observe()`**方法用于异步地监视一个对象的修改。当对象属性被修改时，方法的回调函数会提供一个有序的修改流。然而，这个接口已经被废弃并从各浏览器中移除。你可以使用更通用的[`Proxy`]40537 "Proxy 对象用于定义基本操作的自定义行为 (例如, 属性查找，赋值，枚举，函数调用,等)。")对象替代。 

293 | [Object.preventExtensions()]41455 "") | **ECMAScript 5, JavaScript, Method, Object** 
`**Object.preventExtensions()**`方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。 

294 | [Object.prototype]42225 "") | **JavaScript, Object, Property** 
`**Object.prototype**`属性表示[`Object`]10219 "Object 构造函数创建一个对象包装器。")的原型对象。 

295 | [Object.prototype.__count__]41695 "") | **JavaScript, Object, Obsolete, Property, Prototype** 
**`__count__`**属性曾经用来存放对象的可枚举的属性的个数，但是已经被废除。 

296 | [Object.prototype.__defineGetter__()]41699 "") | **** 
`**__defineGetter__**`方法可以将一个函数绑定在当前对象的指定属性上，当那个属性的值被读取时，你所绑定的函数就会被调用。 

297 | [Object.prototype.__defineSetter__()]41700 "") | **** 
`**__defineSetter__**方法可以将一个函数绑定在当前对象的指定属性`上，当那个属性被赋值时，你所绑定的函数就会被调用。 

298 | [Object.prototype.__lookupGetter__()]41701 "") | **** 
`**__lookupGetter__**`方法会返回当前对象上指定属性的**属性读取访问器函数（getter）。** 

299 | [Object.prototype.__lookupSetter__()]41702 "") | **不建议使用, 原型, 对象, 方法, 过时的, 非标准** 
一个绑定了setter的特殊属性的函数引用。 

300 | [Object.prototype.__noSuchMethod__]41696 "") | **** 
**`__noSuchMethod__`**属性曾经是指当调用某个对象里不存在的方法时即将被执行的函数，但是现在这个函数已经不可用。 

301 | [Object.prototype.__parent__]41697 "") | **** 
指向一个对象的上下文. 

302 | [Object.prototype.__proto__]41446 "") | **Object.prototype.__proto__, Prototype, __proto__, inheritance &amp; prototype_chain** 
[`Object.prototype`]42225 "Object.prototype 属性表示 Object 的原型对象。")的`__proto__`属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部`[[Prototype]]`(一个对象或[`null`]4768 "值 null 是一个 JavaScript 字面量，表示空值（null or an "empty" value），即没有对象被呈现（no object value is present）。它是 JavaScript 原始值 之一。"))。 

303 | [Object.prototype.constructor]41698 "") | **JavaScript, Object, Property, Prototype** 
返回创建实例对象的[`Object`]10219 "Object 构造函数创建一个对象包装器。")构造函数的引用。注意，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。该值为只读的原始类型，如`1`，`true`和`"test"`。 

304 | [Object.prototype.eval()]42236 "") | **** 
`**Object.eval()**`方法用于在对象的上下文中对 JavaScript 代码字符串求值，但该方法已被移除。 

305 | [Object.prototype.hasOwnProperty()]41703 "") | **JavaScript, Method, Object, Object.prototype.hasOwnProperty(), Prototype, 对象** 
`**hasOwnProperty()**`方法会返回一个布尔值，指示对象是否具有指定的属性作为自身（不继承）属性。 

306 | [Object.prototype.isPrototypeOf()]41447 "") | **JavaScript, Object, Prototype, isPrototypeOf(), 原型, 对象, 方法** 
`**isPrototypeOf()**`方法用于测试一个对象是否存在于另一个对象的原型链上。 

307 | [Object.prototype.propertyIsEnumerable()]41704 "") | **JavaScript, Method, Object, Prototype** 
`**propertyIsEnumerable()**`方法返回一个布尔值，表示指定的属性是否可枚举。 

308 | [Object.prototype.toLocaleString()]41705 "") | **JavaScript, Method, Object, Prototype** 
`**toLocaleString()**`方法返回一个该对象的字符串表示。此方被法用于子类对象的设置特定区域的目的。 

309 | [Object.prototype.toSource()]41706 "") | **JavaScript, Method, Object, Prototype** 
**`toSource()`**方法返回一个表示对象源代码的字符串。 

310 | [Object.prototype.toString()]41707 "") | **JavaScript, Method, Object, Prototype** 
`**toString()**`方法返回一个表示该对象的字符串。 

311 | [Object.prototype.unwatch()]41708 "") | **** 
`**unwatch()**`删除一个[`watch()`]41710 "undefined.")设置的 watchpoint. 

312 | [Object.prototype.valueOf()]41709 "") | **JavaScript, Method, Object** 
`**valueOf()**`方法返回指定对象的原始值。 

313 | [Object.prototype.watch()]41710 "") | **Debugging, Deprecated, JavaScript, Method, Object, Obsolete, Prototype** 
[`undefined`]23495 "undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。"). 

314 | [Object.seal()]42237 "") | **** 
`**Object.seal()**`方法可以让一个对象密封，并返回被密封后的对象。密封对象将会阻止向对象添加新的属性，并且会将所有已有属性的可配置性（configurable）置为不可配置（false），即不可修改属性的描述或删除属性。但是可写性描述（writable）为可写（true）的属性的值仍然被修改。 

315 | [Object.setPrototypeOf()]41449 "") | **Array, Class, ECMAScript6, ES6, JavaScript, Object.setPrototypeOf(), Typescript, setPrototypeOf(), 对象, 方法** 
如果对象的[[Prototype]]被修改成不可扩展(通过[`Object.isExtensible()`]41452 "Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。")查看)，就会抛出[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。")异常。如果`prototype`参数不是一个对象或者[`null`]4768 "值 null 是一个 JavaScript 字面量，表示空值（null or an "empty" value），即没有对象被呈现（no object value is present）。它是 JavaScript 原始值 之一。")(例如，数字，字符串，boolean，或者[`undefined`]23495 "undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。"))，则什么都不做。否则，该方法将`obj`的`[[Prototype]]`修改为新的值。 

316 | [Object.unobserve()]42238 "") | **** 
**Object.unobserve()**是用来移除通过[`Object.observe()`]42235 "Object.observe() 方法用于异步地监视一个对象的修改。当对象属性被修改时，方法的回调函数会提供一个有序的修改流。然而，这个接口已经被废弃并从各浏览器中移除。你可以使用更通用的 Proxy 对象替代。")设置的观察者的方法。 

317 | [Object.values()]42239 "") | **JavaScript, Method, Object, Reference** 
`**Object.values()**`方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用[`for...in`]40629 "for...in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。")循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。 

318 | [ParallelArray]44206 "") | **** 
ParallelArray的目标是在web应用程序中让数据并行. 

319 | [Promise]4107 "") | **ECMAScript 2015, JavaScript, Promise** 
**Promise**对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义：诺言，一个成功，一个失败。) 

320 | [Promise.all()]41431 "") | **AJAX, Async-Await, Fetch, Promise, Promise.all(), Promise.race()** 
`**Promise.all()**`方法返回一个[`Promise`]4107 "Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义：诺言，一个成功，一个失败。)"), 在可迭代(`iterable`)参数中所有的 promises 都已经解决了或者当`iterable`参数不包含 promise 时, 返回解决。或者返回拒绝, 当传递的 promise 包含一个拒绝(reject)时。 

321 | [Promise.prototype]42293 "") | **** 
`**Promise**`**`.prototype`**属性表示[`Promise`]4107 "Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义。一个诺言，一个成功，一个失败。)")构造器的原型. 

322 | [Promise.prototype.catch()]42294 "") | **Promise, Promise.prototype.catch()** 
**catch()**方法返回一个[Promise]11338 "")，只处理拒绝的情况。它的行为与调用[`Promise.prototype.then(undefined, onRejected)`]41433 "then() 方法返回一个  Promise 。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。")相同。 

323 | [Promise.prototype.then()]41433 "") | **ECMAScript 2015, JavaScript, Promise, Promise.prototype.then(), Prototype, 方法** 
`**then()**`方法返回一个[`Promise`]11338 "此页面仍未被本地化, 期待您的翻译!")。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。 

324 | [Promise.race()]41432 "") | **Async-Await, Promise, Promise.all(), Promise.race(), parrallel** 
**`Promise.race(iterable)`**方法返回一个**promise**，并伴随着 promise对象解决的返回值或拒绝的错误原因, 只要 iterable 中有一个 promise 对象&quot;解决(resolve)&quot;或&quot;拒绝​​​​​​​(reject)&quot;。 

325 | [Promise.reject()]16550 "") | **** 
`**Promise.reject(reason)**`方法返回一个用reason拒绝的Promise。 

326 | [Promise.resolve()]41430 "") | **** 
`**Promise.resolve(value)**方法`返回一个以给定值解析后的Promise对象。但如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指resolved/rejected/pending/settled）；否则以该值为成功状态返回promise对象。 

327 | [Proxy]40537 "") | **ECMAScript 2015, JavaScript, Proxy** 
Editorial review completed. 

328 | [Proxy.revocable()]41483 "") | **ECMAScript6, Experimental, Expérimental, JavaScript, Method, Proxy** 
`**Proxy.revocable()**`方法可以用来创建一个可撤销的代理对象。 

329 | [处理器对象]41442 "") | **ECMAScript6, Experimental, Expérimental, JavaScript, Proxy** 
处理器对象用来自定义[代理对象]40537 "Proxy 对象用于定义基本操作的自定义行为 (例如属性查找，赋值，枚举，函数调用等)。")的各种可代理操作。 

330 | [handler.apply()]41478 "") | **ECMAScript6, JavaScript, Method, Proxy** 
**`handler.apply()`**方法用于拦截函数的调用。 

331 | [handler.construct()]41481 "") | **** 
`**handler.construct()**`方法用于拦截[`new`]22979 "new 运算符创建一个自定义对象或具有构造函数的内置对象的实例。")操作. 为了使新的操作在生成的Proxy对象上有效，用于初始化代理的目标本身必须具有[[Construct]]内部方法（即`new target`必须是有效的）。 

332 | [handler.defineProperty()]41460 "") | **** 
**`handler.defineProperty()`**用于拦截对对象的[`Object.defineProperty()`]41461 "Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。")操作。 

333 | [handler.deleteProperty()]41469 "") | **** 
**`handler.deleteProperty()`**方法用于拦截对对象属性的[`delete`]40602 "delete 操作符用于删除对象的某个属性。")操作。 

334 | [handler.enumerate()]41471 "") | **** 
代理方法**`handler.enumerate()`**决定了被代理对象在[`for...in`]40629 "for...in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。")中的行为。不过这个方法已经在ES2016标准中被移除了。 

335 | [handler.get()]41465 "") | **ECMAScript6, JavaScript, Method, Proxy** 
**`handler.get()`**方法用于拦截对象的读取属性操作。 

336 | [handler.getOwnPropertyDescriptor()]41457 "") | **** 
**`handler.getOwnPropertyDescriptor()`**方法是[`Object.getOwnPropertyDescriptor()`]41458 "Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）")的陷阱。 

337 | [handler.getPrototypeOf()]41443 "") | **ECMAScript6, Experimental, Expérimental, JavaScript, Method, Proxy** 
**`handler.getPrototypeOf()`**是一个代理方法，当读取代理对象的原型时，该方法就会被调用。 

338 | [handler.has()]41463 "") | **** 
**`handler.has()`**方法可以看作是针对[`in`]40605 "如果指定的属性在指定的对象或其原型链中，则in 运算符返回true。")操作的钩子. 

339 | [handler.ownKeys()]41473 "") | **** 
**`handler.ownKeys()`**方法用于拦截[`Reflect.ownKeys()`]41477 "静态方法 Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组。"). 

340 | [handler.set()]41467 "") | **ECMAScript6, JavaScript, Method, Proxy** 
`**handler.set()**`方法用于拦截设置属性值的操作 

341 | [RangeError]22962 "") | **** 
**RangeError**对象标明一个错误，当一个值不在其所允许的范围或者集合中。 

342 | [ReferenceError]40538 "") | **** 
`**ReferenceError（引用错误）**`对象表明一个不存在的变量被引用。 

343 | [Reflect]40539 "") | **ECMAScript 2015, Proxy, Reflect** 
**Reflect**是一个内置的对象，它提供可拦截JavaScript操作的方法。方法与[代理处理程序]41442 "")的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。 

344 | [Reflect.apply()]41480 "") | **** 
静态方法`**Reflect**`**`.apply()`**通过指定的参数列表发起对目标(target)函数的调用。 

345 | [Reflect.construct()]41482 "") | **** 
`**Reflect**`**`.construct()`**方法的行为有点像[`new`操作符]22497 "")构造函数 ， 相当于运行`new target(...args)`. 

346 | [Reflect.defineProperty()]41462 "") | **ECMAScript 2016, JavaScript, Method, Reflect** 
静态方法`**Reflect**`**`.defineProperty()`**基本等同于[`Object.defineProperty()`]41461 "Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。")方法，唯一不同是返回[`Boolean`]4930 "此页面仍未被本地化, 期待您的翻译!")值。 

347 | [Reflect.deleteProperty()]41470 "") | **** 
静态方法`**Reflect**`**`.deleteProperty()`**允许用于删除属性。它很像[`delete`operator]40903 "")，但它是一个函数。 

348 | [Reflect.enumerate()]41472 "") | **** 
The static`**Reflect**`**`.enumerate()`**method used to return an iterator with the enumerable own and inherited properties of the target object, but has been removed in ECMAScript 2016 and is deprecated in browsers. 

349 | [Reflect.get()]41466 "") | **** 
`**Reflect**`**`.get()`**方法的工作方式，就像从 object (`target[propertyKey]`) 中获取属性，但它是作为一个函数执行的。 

350 | [Reflect.getOwnPropertyDescriptor()]41459 "") | **** 
静态方法`**Reflect**`**`.getOwnPropertyDescriptor()`**与[`Object.getOwnPropertyDescriptor()`]41458 "Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）")方法相似。如果在对象中存在，则返回给定的属性的属性描述符。否则返回[`undefined`]23495 "undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。")。 

351 | [Reflect.getPrototypeOf()]41445 "") | **** 
静态方法`**Reflect**`**`.getPrototypeOf()`**与[`Object.getPrototypeOf()`]41444 "Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。")方法是一样的。都是返回指定对象的原型（即，内部的`[[Prototype]]`属性的值）。 

352 | [Reflect.has()]41464 "") | **** 
静态方法`**Reflect**`**`.has()`**作用与[`in`操作符]40906 "")相同。 

353 | [Reflect.isExtensible()]41453 "") | **** 
`**Reflect**`**`.isExtensible()`**决定一个对象是否可扩展 （即是否能够添加新的属性）。与它[`Object.isExtensible()`]41452 "Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。")方法相似，但有一些不同，详情可见[differences]44207 "")。 

354 | [Reflect.ownKeys()]41477 "") | **** 
静态方法`**Reflect**`**`.ownKeys()`**返回一个由目标对象自身的属性键组成的数组。 

355 | [Reflect.preventExtensions()]41456 "") | **** 
静态方法`**Reflect**`**`.preventExtensions()`**方法阻止新属性添加到对象 例如：防止将来对对象的扩展被添加到对象中)。该方法与[`Object.preventExtensions()`]41455 "Object.preventExtensions()方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。")相似，但有一些不同点。详情可见[differences]44208 "")。 

356 | [Reflect.set()]41468 "") | **** 
静态方法`**Reflect**`**`.set()`**工作方式就像在一个对象上设置一个属性。 

357 | [Reflect.setPrototypeOf()]41450 "") | **** 
静态方法`**Reflect**`**`.setPrototypeOf()`**与[`Object.setPrototypeOf()`]41449 "如果对象的[[Prototype]]被修改成不可扩展(通过 Object.isExtensible()查看)，就会抛出 TypeError异常。如果prototype参数不是一个对象或者null(例如，数字，字符串，boolean，或者 undefined)，则什么都不做。否则，该方法将obj的[[Prototype]]修改为新的值。")方法是一致的。它将指定对象的原型 （即，内部的`[[Prototype]]`属性）设置为另一个对象或为[`null`]4768 "值 null 是一个 JavaScript 字面量，表示空值（null or an "empty" value），即没有对象被呈现（no object value is present）。它是 JavaScript 原始值 之一。")。 

358 | [RegExp]40540 "") | **RegExp, Regular Expressions, 字面量, 工厂符号, 构造函数, 边界字符（Boundaries）** 
**`RegExp`**构造函数创建了一个正则表达式对象，用于将文本与一个模式匹配。 

359 | [RegExp.$1-$9]42355 "") | **** 
非标准**$1, $2, $3, $4, $5, $6, $7, $8, $9**属性是包含括号子串匹配的正则表达式的静态和只读属性。 

360 | [RegExp.input ($_)]42356 "") | **** 
**`input`**非标准属性是正则表达式静态属性，含有正则表达式所匹配的字符串。`RegExp.$_`是这个属性的别名。 

361 | [RegExp.lastIndex]42370 "") | **JavaScript, Property, RegExp, Regular Expressions** 
`**lastIndex**`是正则表达式的一个可读可写的整型属性，用来指定下一次匹配的起始索引。 

362 | [RegExp.lastMatch ($&amp;)]42357 "") | **** 
**lastMatch**非标准属性是正则表达式的静态和只读属性，含有最后匹配到的字符串。`RegExp.$&`是这个属性的别名。 

363 | [RegExp.lastParen ($+)]42358 "") | **** 
**lastParen**非标准属性是正则表达式的静态和只读属性，包含匹配到的最后一个子串（如果存在）。`RegExp.$+`是这一属性的别名。 

364 | [RegExp.leftContext ($`)]42359 "") | **** 
**leftContext**非标准属性是正则表达式的静态和只读属性，含有最新匹配的左侧子串。`RegExp.$``是这个属性的别名。 

365 | [RegExp.prototype]42360 "") | **JavaScript, Property, RegExp** 
[`RegExp`]40540 "RegExp 的构造函数创建了一个正则表达式对象，用模式来匹配文本。")构造函数的原型对象。 

366 | [RegExp.prototype.compile()]42371 "") | **Deprecated, JavaScript** 
`已废弃的**compile**`**`()`**方法被用于在脚本执行过程中（重新）编译正则表达式。与`RegExp`构造函数基本一样。 

367 | [RegExp.prototype.exec()]41327 "") | **## lastIndex bug???, JavaScript, Method, Prototype, RegExp, Regular Expressions** 
`**exec()**`方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或[`null`]4768 "值 null 是一个 JavaScript 字面量，表示空值（null or an "empty" value），即没有对象被呈现（no object value is present）。它是 JavaScript 原始值 之一。")。 

368 | [RegExp.prototype.flags]42361 "") | **** 
**`flags`**属性返回一个字符串，由当前正则表达式对象的标志组成。 

369 | [RegExp.prototype.global]42362 "") | **JavaScript, Property, Prototype, RegExp** 
`**global**`属性表明正则表达式是否使用了 &quot;`g`&quot; 标志。`global`是一个正则表达式实例的只读属性。 

370 | [RegExp.prototype.ignoreCase]42363 "") | **JavaScript, Property, RegExp, prototype** 
`**ignoreCase**`属性表明正则表达式是否使用了 &quot;`i`&quot; 标志。`ignoreCase`是正则表达式实例的只读属性。 

371 | [RegExp.prototype.multiline]42364 "") | **JavaScript, Property, RegExp, Regular Expressions, prototype** 
`**multiline**`属性表明正则表达式是否使用了 &quot;`m`&quot; 标志。`multiline`是正则表达式实例的一个只读属性。 

372 | [RegExp.prototype.source]42365 "") | **JavaScript, Property, Reference, RegExp, Regular Expressions, Référence, prototype** 
**`source`**属性返回一个值为当前正则表达式对象的模式文本的字符串，该字符串不会包含正则字面量两边的斜杠以及任何的标志字符。 

373 | [RegExp.prototype.sticky]42366 "") | **** 
**`sticky`**属性反映了搜索是否具有粘性（ 仅从正则表达式的[`lastIndex`]42370 "lastIndex 是正则表达式的一个可读可写的整型属性，用来指定下一次匹配的起始索引。")属性表示的索引处搜索 ）。`sticky`是正则表达式对象的只读属性。 

374 | [RegExp.prototype.test()]41328 "") | **JavaScript, Method, Prototype, RegExp, Regular Expressions** 
`**test()**`方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回`true`或`false`。 

375 | [RegExp.prototype.toSource()]42372 "") | **JavaScript, Method, Non-standard, RegExp, prototype** 
返回一个字符串,代表当前对象的源代码 

376 | [RegExp.prototype.toString()]42373 "") | **JavaScript, Method, Prototype, RegExp** 
`**toString()**`返回一个表示该正则表达式的字符串。 

377 | [RegExp.prototype.unicode]42367 "") | **** 
**`unicode`**属性表明正则表达式带有&quot;`u`&quot; 标志。`unicode`是正则表达式独立实例的只读属性。 

378 | [RegExp.prototype[@@match]()]42374 "") | **** 
对*正则表达式*匹配*字符串*时，**`[@@match]()`**方法用于获取匹配结果。 

379 | [RegExp.prototype[@@replace]()]42375 "") | **JavaScript, RegExp, 正则表达式** 
**`[@@replace]()`**方法会在一个字符串中用给定的替换器，替换所有符合正则模式的匹配项，并返回替换后的新字符串结果。用来替换的参数可以是一个字符串或是一个针对每次匹配的回调函数。 

380 | [RegExp.prototype[@@search]()]42376 "") | **** 
**`[@@search]()`**方法执行了一个在给定字符串中的一个搜索以取得匹配正则模式的项。 

381 | [RegExp.prototype[@@split]()]42377 "") | **** 
**`[@@split]()`**方法切割[`String`]4402 "此页面仍未被本地化, 期待您的翻译!")对象为一个其子字符串的数组 。 

382 | [RegExp.rightContext ($&#39;)]42368 "") | **** 
**rightContext**非标准属性是正则表达式的静态和只读属性，含有最新匹配的右侧子串。`RegExp.$'`是这个属性的别名。 

383 | [get RegExp[@@species]]42369 "") | **** 
`**RegExp[@@species]**`访问器属性返回`RegExp`的构造器。 

384 | [SIMD]40541 "") | **Experimental, JavaScript, NeedsTranslation, SIMD, TopicStub** 
[SIMD]41620 "SIMD: SIMD (pronounced "seem-dee") is short for Single Instruction/Multiple Data which is one classification of computer architectures. SIMD allows one same operation to be performed on multiple data points resulting in data level parallelism and thus performance gains, for example for 3D graphics and video processing, physics simulations or cryptography, and other domains.")(pronounced &quot;sim-dee&quot;) is short for**Single Instruction/Multiple Data**which is one[classification of computer architectures]42504 ""). SIMD operations perform the same computation on multiple data points resulting in data level parallelism and thus performance gains, for example for 3D graphics and video processing, physics simulations or cryptography, and other domains. 

385 | [SIMD.%type%.abs()]42407 "") | **** 
**`SIMD.%type%.abs()`**方法返回原 SIMD 值的绝对值。该方法只存在于 SIMD 浮点数类型上。 

386 | [SIMD.%type%.add()]42408 "") | **** 
**`SIMD.%type%.add()`**方法对两个 SIMD 值进行求和操作。 

387 | [SIMD.%type%.and()]42413 "") | **** 
SIMD.js has been[taken out of active development in TC39]41628 "")and removed from Stage 3. It is not being pursued by web browsers for implementation anymore. SIMD operations exposed to the web are under active development within[WebAssembly]21620 ""), with operations based on the SIMD.js operations. 

388 | [SIMD.Bool16x8]40542 "") | **** 
SIMD.js has been[taken out of active development in TC39]41628 "")and removed from Stage 3. It is not being pursued by web browsers for implementation anymore. SIMD operations exposed to the web are under active development within[WebAssembly]21620 ""), with operations based on the SIMD.js operations. 

389 | [SIMD.Bool32x4]40543 "") | **** 
SIMD.js has been[taken out of active development in TC39]41628 "")and removed from Stage 3. It is not being pursued by web browsers for implementation anymore. SIMD operations exposed to the web are under active development within[WebAssembly]21620 ""), with operations based on the SIMD.js operations. 

390 | [Set]40561 "") | **ECMAScript6, JavaScript, set, 集合** 
**`Set`**对象允许你存储任何类型的唯一值，无论是[原始值]41155 "原始值: A primitive (primitive value, primitive data type) is data that is not an object and has no methods. In JavaScript, there are 6 primitive data types: string, number, boolean, null, undefined, symbol (new in ECMAScript 2015).")或者是对象引用。 

391 | [Set.prototype]42632 "") | **ECMAScript6, JavaScript, set, 属性** 
`**Set**`**`.prototype`**属性表示[`Set`]40561 "集合（Set）对象允许你存储任意类型的唯一值（不能重复），无论它是原始值或者是对象引用。")构造器的原型。 

392 | [Set.prototype.add()]42635 "") | **ECMAScript6, JavaScript, Prototype, set, 原型, 方法** 
`**add()**`方法用来向一个`Set`对象的末尾添加一个指定的值。 

393 | [Set.prototype.clear()]42636 "") | **ECMAScript6, JavaScript, Prototype, set, 原型, 方法** 
`**clear()**`方法用来清空一个`Set`对象中的所有元素。 

394 | [Set.prototype.delete()]42637 "") | **ECMAScript6, JavaScript, set, 方法** 
`**delete()**`方法可以从一个`Set`对象中删除指定的元素。 

395 | [Set.prototype.entries()]42638 "") | **** 
entries() 方法返回一个新的迭代器对象 ，这个对象的元素是类似 [value, value] 形式的数组，value 是集合对象中的每个元素，迭代器对象元素的顺序即集合对象中元素插入的顺序。由于集合对象不像 Map 对象那样拥有 key，然而，为了与 Map 对象的 API 形式保持一致，故使得每一个 entry 的 key 和 value 都拥有相同的值，因而最终返回一个 [value, value] 形式的数组。 

396 | [Set.prototype.forEach()]42639 "") | **** 
forEach 方法根据集合中元素的顺序，对每个元素都执行提供的 callback 函数一次。 

397 | [Set.prototype.has()]42640 "") | **** 
**has()**方法返回一个布尔值来指示对应的值value是否存在Set对象中 

398 | [Set.prototype.size]42633 "") | **** 
**Size**属性将会返回[`Set`]40561 "Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。")对象中元素的个数。 

399 | [Set.prototype.values()]42641 "") | **** 
`**values()**`方法返回一个`**Iterator**`对象，这个对象以插入Set 对象的顺序包含了原 Set 对象里的每个元素。 

400 | [Set.prototype[@@iterator]()]42642 "") | **** 
The initial value of the`**@@iterator**`property is the same function object as the initial value of the[`values`]42641 "values() 方法返回一个 Iterator  对象，这个对象以插入Set 对象的顺序包含了原 Set 对象里的每个元素。")property. 

401 | [SharedArrayBuffer]20239 "") | **ArrayBuffer, Service Worker, Shared Memory, SharedArrayBuffer, TypedArrays, Web Worker, Worker, 共享内存, 实验的, 构造函数** 
**`SharedArrayBuffer`**对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于[`ArrayBuffer`]3602 "一个新的拥有指定大小的ArrayBuffer对象。它的内容都被初始化为0。")对象。对象，但它们可以用来在共享内存上创建视图。与`ArrayBuffer`不同的是，`**SharedArrayBuffer**`不能被分离。 

402 | [SharedArrayBuffer.prototype]42649 "") | **Prototype, SharedArrayBuffer** 
**`SharedArrayBuffer.prototype`**属性表示[`SharedArrayBuffer`]20239 "SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象。对象，但它们可以用来在共享内存上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。")对象的原型。 

403 | [SharedArrayBuffer.prototype.byteLength]42650 "") | **SharedArrayBuffer** 
`**byteLength**`访问器属性表示以字节为单位的一个[`SharedArrayBuffer`]20239 "SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象。对象，但它们可以用来在共享内存上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。")的长度。 

404 | [SharedArrayBuffer.prototype.slice()]42651 "") | **SharedArrayBuffer, slice** 
`**SharedArrayBuffer.prototype.slice()**`方法返回一个新的[`SharedArrayBuffer`]20239 "SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象。对象，但它们可以用来在共享内存上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。")其内容是该SharedArrayBuffer的字节从开始包含，直到结束，独占的副本。如果开始或结束是负的，它指的是从数组末尾开始的索引。此方法与[`Array.prototype.slice()`]3662 "slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。原始数组不会被修改。")具有相同的算法。 

405 | [String]40562 "") | **JavaScript, String, 字符串泛型方法, 已废弃** 
**`String`**全局对象是一个用于字符串或一个字符序列的构造函数。 

406 | [String.fromCharCode()]41311 "") | **** 
静态**`String.fromCharCode()`**方法返回使用指定的Unicode值序列创建的字符串。 

407 | [String.fromCodePoint()]41301 "") | **** 
**`String.fromCodePoint() 静态方法返回使用指定的代码点序列创建的字符串。`** 

408 | [String.length]41493 "") | **JavaScript, Property, Prototype, String** 
**length**属性表示一个字符串的长度。 

409 | [String.prototype]42661 "") | **JavaScript, 原型, 参考, 字符串, 属性** 
`**String.prototype**`属性表示[`String`]4402 "此页面仍未被本地化, 期待您的翻译!")原型对象。 

410 | [String.prototype.anchor()]42662 "") | **HTML, JavaScript, Method, Prototype, String** 
`**anchor()**`方法创建一个[`<a>`]12085 "HTML <a> 元素  (或锚元素) 创建一个到其他网页，文件，同一页面内的位置，电子邮件地址或任何其他URL的超链接。")HTML 锚元素，被用作超文本靶标（hypertext target）。 

411 | [String.prototype.big()]42663 "") | **** 
**`big()`**方法的作用是创建一个使字符串显示大号字体的[`<big>`]38790 "The HTML Big Element (<big>) 会使字体加大一号（例如从小号(small)到中号(medium)，从大号(large)到加大(x-large)），最大不超过浏览器的最大字体。")标签。 

412 | [String.prototype.blink()]42664 "") | **** 
**`blink()`**方法创建使字符串闪烁的[`<blink>`]13571 "HTML Blink Element (<blink>)不是标准元素，它会使包含其中的文本闪烁。")HTML 元素。 

413 | [String.prototype.bold()]42665 "") | **Deprecated, HTML wrapper methods, JavaScript** 
{{JSRef}} {{deprecated_header}} 

414 | [String.prototype.charAt()]41303 "") | **String.prototype.charAt()** 
**charAt()**方法从一个字符串中返回指定的字符。 

415 | [String.prototype.charCodeAt()]41304 "") | **** 
`**charCodeAt()**`方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 &gt; 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。如果你想要整个代码点的值，使用**`codePointAt`**()。 

416 | [String.prototype.codePointAt()]41302 "") | **** 
**`codePointAt()`**方法返回 一个 Unicode 编码点值的非负整数。 

417 | [String.prototype.concat()]41310 "") | **JavaScript, Method, Prototype, String** 
**`concat()`**方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。 

418 | [String.prototype.endsWith()]41308 "") | **Experimental, Expérimental(2), JavaScript, Method, Prototype, String** 
`**endsWith()**`方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回`true`或`false`。 

419 | [String.prototype.fixed()]42666 "") | **Deprecated, HTML wrapper methods, JavaScript** 
fixed()方法创建了一个&lt;tt&gt;标签元素将字符串包裹起来，从而让这个字符串里面的内容具有固定间距。&lt;/tt&gt; 

420 | [String.prototype.fontcolor()]42667 "") | **Deprecated, HTML wrapper methods, JavaScript, Method, Prototype, Reference, String** 
**`fontcolor()`** 

421 | [String.prototype.fontsize()]42668 "") | **** 
The**`fontsize()`**method creates a[`<font>`]38807 "HTML Font 元素（<font>）定义了该内容的字体大小、顏色与表现。")HTML element that causes a string to be displayed in the specified font size. 

422 | [String.prototype.includes()]41309 "") | **JavaScript, Method, Monkey patching, Prototype, String, String.prototype.includes()** 
**`includes()`**`方法用于`判断一个字符串是否包含在另一个字符串中，根据情况返回true或false。 

423 | [String.prototype.indexOf()]41305 "") | **JavaScript, String, String.indexOf(), 原型, 参考, 字符串, 方法** 
`**indexOf()**`方法返回调用[`String`]4402 "此页面仍未被本地化, 期待您的翻译!")对象中第一次出现的指定值的索引，开始在 fromIndex进行搜索。 

424 | [String.prototype.italics()]42669 "") | **** 
The**`italics()`**method creates an[`<i>`]38814 "HTML元素 <i> 用于表现因某些原因需要区分普通文本的一系列文本。例如技术术语、外文短语或是小说中人物的思想活动等，它的内容通常以斜体显示。")HTML element that causes a string to be italic. 

425 | [String.prototype.lastIndexOf()]41306 "") | **** 
`**lastIndexOf()**`方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。从该字符串的后面向前查找，从`fromIndex`处开始。 

426 | [String.prototype.link()]42670 "") | **** 
`**link()**`方法创建一个[`<a>`]12085 "HTML 中的 <a>元素 (或HTML锚元素, Anchor Element) 用于定义一个超链接到其他网络页面，文件，相同页面的某个位置，电子邮件地址或其他任何URL。")HTML 元素，用该字符串作为超链接的显示文本，参数作为指向另一个 URL 的超链接。 

427 | [String.prototype.localeCompare()]42068 "") | **Internationalization, JavaScript, String.prototype.localeCompare(), 原型, 参考, 字符串, 方法** 
**`localeCompare()`**方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。 

428 | [String.prototype.match()]41316 "") | **** 
当一个字符串与一个正则表达式匹配时，**`match()`**方法检索匹配项。 

429 | [String.prototype.normalize()]41321 "") | **ECMAScript6, Experimental, Expérimental(2), JavaScript, Method, String, Unicode** 
**normalize()**方法会按照指定的一种 Unicode 正规形式将当前字符串正规化. 

430 | [String.prototype.padEnd()]42671 "") | **** 
**`padEnd()`**方法会用第二个参数中指定的填充字符串，在当前字符串的尾部不断填充，直到它达到第一个参数中指定的目标长度。 

431 | [String.prototype.padStart()]42672 "") | **** 
**`padStart()`**方法会用一个字符串填充当前字符串（如果需要的话会重复填充），在当前字符串的头部不断填充，直到它达到第一个参数中指定的目标长度。 

432 | [String.prototype.quote()]42673 "") | **JavaScript, Method, Non-standard, Obsolete, String, prototype** 
将字符串中包含的特殊字符进行转义(反斜杠),然后在字符串两边各加上一个双引号(`"`)并返回,并不修改原字符串. 

433 | [String.prototype.repeat()]41322 "") | **ECMAScript 2015, ES 6, JavaScript, Method, Prototype, Reference, String, polyfill, repeat(), 填充** 
**`repeat()`**构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。 

434 | [String.prototype.replace()]41317 "") | **JavaScript, Method, Prototype, Regular, String** 
**`replace()`**方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个[正则表达式]40773 ""), 替换值可以是一个字符串或者一个每次匹配都要调用的函数。 

435 | [String.prototype.search()]41318 "") | **** 
`**search()**`方法执行正则表达式和[`String`]4402 "此页面仍未被本地化, 期待您的翻译!")对象之间的一个搜索匹配。 

436 | [String.prototype.slice()]41313 "") | **JavaScript, Method, Prototype, String, String.prototype.slice()** 
**`slice()`**方法提取一个字符串的一部分，并返回一新的字符串。 

437 | [String.prototype.small()]42674 "") | **** 
**`small()`**方法的作用是创建一个使字符串显示小号字体的[`<small>`]26121 "HTML 中的元素將使文本的字体变小一号。(例如从大变成中等，从中等变成小，从小变成超小)。在HTML5中，除了它的样式含义，这个元素被重新定义为表示边注释和附属细则，包括版权和法律文本。")标签。 

438 | [String.prototype.split()]41312 "") | **), String to Array &amp; Array.toString(), String.prototype.split(), split(** 
`**split()**`方法使用指定的分隔符字符串将一个[`String`]4402 "此页面仍未被本地化, 期待您的翻译!")对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。 

439 | [String.prototype.startsWith()]41307 "") | **ECMAScript6, Experimental, Expérimental(2), JavaScritp, Method, Prototype, String** 
`**startsWith()**`方法用来判断当前字符串是否是以另外一个给定的子字符串“开头”的，根据判断结果返回`true`或`false`。 

440 | [String.prototype.strike()]42675 "") | **** 
**`strike()`**方法创建[`<strike>`]38837 "HTML <strike> 元素（或者 HTML 删除线元素）在文本上放置删除线。")HTML 元素，使字符串展示为被删除的文本。 

441 | [String.prototype.sub()]42676 "") | **String.sub(), 已废弃** 
**`sub()`**方法创建一个[`<sub>`]38838 "HTML <sub> 元素定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更低并且更小。")HTML 元素，使字符串展示为下标。 

442 | [String.prototype.substr()]41315 "") | **String.prototype.substr()** 
`**substr()**`方法返回一个字符串中从指定位置开始到指定字符数的字符。 

443 | [String.prototype.substring()]41314 "") | **String.prototype.substring()** 
**`substring()`**方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。 

444 | [String.prototype.sup()]42677 "") | **String.prototype.sup()** 
**`sup()`**方法创建 一个[`<sup>`]38839 "HTML <sup> 元素定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更高并且更小。")HTML 元素，使字符串显示为上标。 

445 | [String.prototype.toLocaleLowerCase()]42678 "") | **** 
**`toLocaleLowerCase()`**方法根据任何特定于语言环境的案例映射，返回调用字符串值转换为小写的值。 

446 | [String.prototype.toLocaleUpperCase()]42679 "") | **** 
**`toLocaleUpperCase()`**使用本地化（locale-specific）的大小写映射规则将输入的字符串转化成大写形式并返回结果字符串。 

447 | [String.prototype.toLowerCase()]41319 "") | **JavaScript, Method, Prototype, String, toLowerCase()** 
`**toLowerCase()**`会将调用该方法的字符串值转为小写形式，并返回。 

448 | [String.prototype.toSource()]42680 "") | **** 
**`toSource()`**方法返回一个代表对象的源代码。 

449 | [String.prototype.toString()]42681 "") | **** 
`**toString()**`方法返回指定对象的字符串形式。 

450 | [String.prototype.toUpperCase()]41320 "") | **JavaScript, Method, Prototype, String** 
`**toUpperCase()**`将调用该方法的字符串值转换为大写形式，并返回。 

451 | [String.prototype.trim()]42682 "") | **ECMAScript5, JavaScript, Method, Prototype, String, String.prototype.trim()** 
**`trim()`**方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。 

452 | [String.prototype.trimLeft()]42684 "") | **JavaScript, Method, Prototype, String, trimLeft()** 
`trimLeft`方法移除原字符串左端的连续空白符并返回`,trimLeft`方法并不会直接修改原字符串本身. 

453 | [String.prototype.trimRight()]42683 "") | **JavaScript, Method, Prototype, String** 
**trimRight()**方法从一个字符串的右端移除空白字符。 

454 | [String.prototype.valueOf()]42685 "") | **** 
`**valueOf()**`方法返回一个[`String`]4402 "此页面仍未被本地化, 期待您的翻译!")对象的原始值（primitive value）。 

455 | [String.prototype[@@iterator]()]42686 "") | **** 
**`[@@iterator]()`**方法返回一个新的Iterator对象，它遍历字符串的代码点，返回每一个代码点的字符串值。 

456 | [String.raw()]42687 "") | **ECMAScript6, Experimental, Expérimental(2), JavaScript, Method, String** 
**String.raw()**是一个[模板字符串]44209 "")的标签函数，它的作用类似于 Python 中的字符串前缀`r`和 C# 中的字符串前缀`@`，是用来获取一个模板字符串的原始字面量值的。 

457 | [Symbol]40563 "") | **ECMAScript6, JavaScript, Symbol** 
`Symbol()`函数会返回**symbol**类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：&quot;`new Symbol()`&quot;。 

458 | [Symbol.for()]42711 "") | **JavaScript, Method, Symbol** 
`**Symbol.for(key)**`方法会根据给定的键`key`，来从运行时的 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中。 

459 | [Symbol.hasInstance]42701 "") | **** 
**`Symbol.hasInstance 用于判断某对象是否为某构造器的实例。`**因此你可以用它自定义[`instanceof`]40606 "instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。")操作符在某个类上的行为。 

460 | [Symbol.isConcatSpreadable]42702 "") | **** 
内置的**`Symbol.isConcatSpreadable`**`符号用于配置某对象作为`[`Array.prototype.concat()`]41382 "concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。")方法的参数时是否展开其数组元素。 

461 | [Symbol.iterator]41436 "") | **ECMAScript 2015, JavaScript, Property, Symbol** 
**Symbol.iterator**为每一个对象定义了默认的迭代器。该迭代器可以被`[for...of]13613 "")`循环使用。 

462 | [Symbol.keyFor()]42712 "") | **** 
`**Symbol.keyFor(sym)**`方法用来获取 symbol 注册表中与某个 symbol 关联的键。 

463 | [Symbol.match]42703 "") | **ECMAScript6, JavaScript, Symbol, 属性** 
`**Symbol.match**`指定了匹配的是正则表达式而不是字符串。[`String.prototype.match()`]41316 "当一个字符串与一个正则表达式匹配时， match()方法检索匹配项。")方法会调用此函数。 

464 | [Symbol.prototype]42704 "") | **** 
Technical review completed. Editorial review completed. 

465 | [Symbol.prototype.toSource()]42713 "") | **** 
`**toSource()**`方法返回代表该对象源码的字符串。 

466 | [Symbol.prototype.toString()]42714 "") | **** 
`**toString()**`方法返回当前 symbol 对象的字符串表示。 

467 | [Symbol.prototype.valueOf()]42715 "") | **** 
`**valueOf()**`方法返回当前 symbol 对象所包含的 symbol 原始值。 

468 | [Symbol.prototype[@@toPrimitive]]42716 "") | **** 
`**[@@toPrimitive]()**`方法可将 Symbol 对象转换为原始值。 

469 | [Symbol.replace]42705 "") | **** 
`**Symbol.replace**`这个属性指定了当一个字符串替换所匹配字符串时所调用的方法。[`String.prototype.replace()`]41317 "replace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式, 替换值可以是一个字符串或者一个每次匹配都要调用的函数。")方法会调用此方法。 

470 | [Symbol.search]42706 "") | **** 
`Symbol.search 指定了一个搜索方法，这个方法接受用户输入的正则表达式，返回该正则表达式在字符串中匹配到的下标，这个方法由以下的方法来调用`[`String.prototype.search()`]41318 "search() 方法执行正则表达式和 String对象之间的一个搜索匹配。")。 

471 | [Symbol.species]42707 "") | **** 
`**Symbol.species**`是指定一个构造函数创建派生对象的函数值属性。 

472 | [Symbol.split]42708 "") | **** 
`**Symbol.split**`指向 一个正则表达式的索引处分割字符串的方法。 这个方法通过[`String.prototype.split()`]41312 "split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。")调用。 

473 | [Symbol.toPrimitive]42709 "") | **** 
`**Symbol.toPrimitive**`指将被调用的指定函数值的属性转换为相对应的原始值。 

474 | [Symbol.toStringTag]42710 "") | **** 
**`Symbol.toStringTag`**是一个内置 symbol，它通常作为对象的属性键使用，对应的属性值应该为字符串类型，这个字符串用来表示该对象的自定义类型标签，通常只有内置的[`Object.prototype.toString()`]41707 "toString() 方法返回一个表示该对象的字符串。")方法会去读取这个标签并把它包含在自己的返回值里。 

475 | [Symbol.unscopables]23765 "") | **** 
**`Symbol.unscopables`**指用于指定对象值，其对象自身和继承的从关联对象的 with 环境绑定中排除的属性名称。 

476 | [SyntaxError]40564 "") | **Error, JavaScript, Object, SyntaxError** 
`**SyntaxError**`对象代表尝试解析语法上不合法的代码的错误。 

477 | [SyntaxError.prototype]42724 "") | **Error, JavaScript, Property, Prototype, SyntaxError** 
`**SyntaxError.prototype**`属性表示[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误.")构造器的原型. 

478 | [TypeError]3682 "") | **Error, JavaScript, Object, Reference, Référence, TypeError, 参考, 类型错误** 
`**TypeError（类型错误）**`对象用来表示值的类型非预期类型时发生的错误。 

479 | [TypeError.prototype]42728 "") | **Error, JavaScript, TypeError, 原型, 错误** 
The`**TypeError.prototype**`property represents the prototype for the[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。")constructor. 

480 | [TypedArray]5141 "") | **JavaScript, TypedArray, TypedArrays** 
一个**TypedArray**对象描述一个底层的[二进制数据缓存区]3602 "")的一个类似数组(array-like)视图。没有名为**TypedArray**的全局属性，也没有一个直接可见的**TypedArray**构造函数。相反，有许多不同的全局属性，其值是下面列出的特定元素类型的类型化数组构造函数。在下面的页面中，你会找到可用于包含任何类型的元素的任何类型数组的常见属性和方法 

481 | [TypedArray.BYTES_PER_ELEMENT]3612 "") | **** 
`**TypedArray.BYTES_PER_ELEMENT**`属性代表了强类型数组中每个元素所占用的字节数。 

482 | [TypedArray.from()]3616 "") | **** 
`***TypedArray*.from()**`方法 从一个类数组或者可迭代对象中创建一个新类型数组。 这个方法和[`Array.from()`]3617 "Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例。")类似。 

483 | [TypedArray.name]3613 "") | **JavaScript, Property, TypedArray, TypedArrays, 构造函数** 
`***TypedArray*.name**`属性是描述类型数组构造名的字符串值。 

484 | [TypedArray.of()]3618 "") | **Typed, TypedArray, TypedArray.fo(), TypedArray.from()** 
`***TypedArray*.of()**`方法创建一个具有可变数量参数的新[类型数组]22414 "")。此方法几乎与[`Array.of()`]3619 "Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。")相同。 

485 | [TypedArray.prototype]3615 "") | **** 
`**TypedArray**`**`.prototype`**属性表示{{jsxref(&quot;TypedArray&quot;)}}构造器的原型. 

486 | [TypedArray.prototype.buffer]3621 "") | **** 
**`buffer`**访问器属性表示由*TypedArray*在构造期间引用的[`ArrayBuffer`]3602 "一个新的拥有指定大小的ArrayBuffer对象。它的内容都被初始化为0。")。 

487 | [TypedArray.prototype.byteLength]3622 "") | **** 
**`byteLength`**访问器属性表示类型化数组的长度（字节数）。 

488 | [TypedArray.prototype.byteOffset]3623 "") | **** 
**`byteOffset`**访问器属性表示类型化数组距离其[`ArrayBuffer`]3602 "一个新的拥有指定大小的ArrayBuffer对象。它的内容都被初始化为0。")起始位置的偏移（字节数）。 

489 | [TypedArray.prototype.copyWithin()]3625 "") | **** 
`**copyWithin()**`方法将数组中的元素序列复制到以`target`起始的位置。 副本取自第二个参数和第三个参数`start`和`end`的位置下标。`end`参数是可选的，默认为数组长度。这个方法的算法和[`Array.prototype.copyWithin`]3626 "改变了的数组。")*相同。**TypedArray*是这里的[类型化数组类型]3620 "")之一。 

490 | [TypedArray.prototype.entries()]3627 "") | **** 
The**`entries()`**返回新的`Array Iterator`对象，包含数组每个下标处的键值对。 

491 | [TypedArray.prototype.every()]3629 "") | **** 
`**every()**`方法测试类型化数组的所有元素是否都能够通过由提供函数实现的测试。这个方法的算法与[`Array.prototype.every()`]3630 "every() 方法测试数组的所有元素是否都通过了指定函数的测试。")相同。*TypedArray*是这里的[类型化数组类型]3620 "")之一。 

492 | [TypedArray.prototype.fill()]3631 "") | **** 
`**fill()**方法将`类型化数组中的从起始索引到终止索引内的全部元素。这个方法的算法和 {{jsxref(&quot;Array.prototype.fill()&quot;)}} 相同。*TypedArray*是这里的[类型化数组类型]3620 "")之一。 

493 | [TypedArray.prototype.filter()]3633 "") | **** 
`**filter()**`创建新的类型化数组，含有所有通过了测试的元素，测试由提供的函数实现。这个方法的算法和[`Array.prototype.filter()`]3634 "filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。")*相同。**TypedArray*是这里的[类型化数组类型]3620 "")之一。 

494 | [TypedArray.prototype.find()]3635 "") | **** 
如果某个元素满足所提供的测试函数，`**find()**`方法返回类型化数组中的**值**。否则返回[`undefined`]23495 "undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。")。*TypedArray*是这里的[类型化数组类型]3620 "")之一。 

495 | [TypedArray.prototype.findIndex()]3637 "") | **** 
如果某个元素满足所提供的测试函数，`**findIndex()**`方法返回类型化数组中的**下标**。否则返回 -1。*TypedArray*是这里的[类型化数组类型]3620 "")之一。 

496 | [TypedArray.prototype.forEach()]3639 "") | **** 
`**forEach()**`方法对类型化数组的每个元素调用提供的函数。 这个方法的算法和[`Array.prototype.forEach()`]3640 "forEach() 方法对数组的每个元素执行一次提供的函数。")*相同。**TypedArray*是这里的[类型化数组类型]3620 "")之一。 

497 | [TypedArray.prototype.includes()]3641 "") | **** 
`**includes()**`方法判断类型化数组中是否含有特定元素，并相应返回`true`或者`false`，这个方法的算法和[`Array.prototype.includes()`]3642 "includes() 方法用来判断一个数组是否包含一个指定的值，如果是，酌情返回 true或 false。")*相同。**TypedArray*是这里的[类型化数组]3620 "")之一。 

498 | [TypedArray.prototype.indexOf()]3643 "") | **TypedArray, Uint8Array** 
`**indexOf()**`方法返回在类型数组中可以找到给定元素的第一个索引，如果不存在，则返回-1。 方法具有与[`Array.prototype.indexOf()`]3644 "indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。")相同的算法。 TypedArray是这里的[类型化数组类型]3620 "")之一。 

499 | [TypedArray.prototype.join()]3645 "") | **** 
`**join()**`方法将数组中所有元素连接为一个字符串。这个方法的算法和[`Array.prototype.join()`]3646 "join() 方法将数组（或一个类数组对象）的所有元素连接到一个字符串中。")*相同。**TypedArray*是这里的[类型化数组]3620 "")之一。 

500 | [TypedArray.prototype.keys()]3647 "") | **** 
**`keys()`**方法返回新的`Array Iterator`对象，包含数组中每个下标的键。 

501 | [TypedArray.prototype.lastIndexOf()]3649 "") | **** 
`**lastIndexOf()**`方法返回在类型数组中可以找到给定元素的最后一个索引，如果不存在，则返回-1。 方法具有与[`Array.prototype.lastIndexOf()`]3650 "lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。")相同的算法。 TypedArray是这里的[类型化数组类型]3620 "")之一。 

502 | [TypedArray.prototype.length]3624 "") | **** 
**`length`**访问器属性表示类型化数组的长度（元素数）。 

503 | [TypedArray.prototype.map()]3651 "") | **** 
`**map()**`方法对类型化数组的每个元素调用提供的函数，并使用结果来创建新的类型化数组。 这个方法的算法和[`Array.prototype.map()`]3652 "map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。")*相同。**TypedArray*是这里的[类型化数组类型]3620 "")之一。 

504 | [TypedArray.prototype.move()]3653 "") | **** 
**`move()`**方法将数组中的元素序列复制到以`target`起始的位置。但是，这个非标准方法已经被[`TypedArray.prototype.copyWithin()`]3625 "copyWithin()方法将数组中的元素序列复制到以target起始的位置。 副本取自第二个参数和第三个参数 start 和end的位置下标。end 参数是可选的，默认为数组长度。这个方法的算法和Array.prototype.copyWithin相同。 TypedArray 是这里的 类型化数组类型 之一。")标准方法取代。*TypedArray*是这里的[类型化数组类型]3620 "")之一。 

505 | [TypedArray.prototype.reduce()]3654 "") | **** 
`**reduce()**`方法接受一个函数作为参数，这个函数作为一个累加器，从左到右遍历整个类型数组，最后返回一个单一的值. 这个方法和[`Array.prototype.reduce()`]3655 "reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。")使用了同样的算法.*TypedArray*是一个[类型数组]3620 ""). 

506 | [TypedArray.prototype.reduceRight()]3656 "") | **** 
`**reduceRight()**`在累加器和类型化数组的每个元素上（从右到左）调用函数，使其归约为单一的值。这个方法的算法和[`Array.prototype.reduceRight()`]3657 "reduceRight() 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。")相同。*TypedArray*是这里的[类型化数组类型]3620 "")之一。 

507 | [TypedArray.prototype.reverse()]3658 "") | **** 
`**reverse()**`方法原地翻转类型化数组。类型化数组的第一个元素变为最后一个，最后一个变为第一个。这个方法的算法和[`Array.prototype.reverse()`]3659 "reverse() 方法将数组中元素的位置颠倒。")*相同。**TypedArray*是这里的[类型化数组类型]3620 "")之一。 

508 | [TypedArray.prototype.set()]3660 "") | **** 
**`set()`**方法用于从指定数组中读取值，并将其存储在类型化数组中。 

509 | [TypedArray.prototype.sort()]3665 "") | **** 
`**sort()**`方法*原地*排序类型化数组的元素，并且返回类型化数组。这个方法的算法和[`Array.prototype.sort()`]3666 "sort() 方法在适当的位置对数组的元素进行排序，并返回数组。 sort 排序不一定是稳定的。默认排序顺序是根据字符串Unicode码点。")*相同。**TypedArray*是这里的[类型化数组类型]3620 "")之一。 

510 | [TypedArray.prototype.toString()]3672 "") | **** 
`**toString()**`方法返回一个表示指定数组及其元素的字符串。这个方法的算法和[`Array.prototype.toString()`]3673 "toString() 返回一个字符串，表示指定的数组及其元素。")*一样。**TypedArray*在这是[typed array types]44210 "")之一。 

511 | [TypedArray.prototype.values()]3668 "") | **** 
**`values()`**返回新的`Array Iterator`对象，包含数组中每个下标处的值。 

512 | [TypedArray.prototype[@@iterator]()]3674 "") | **** 
@@iterator 的初始值是和[`values`]3668 "values()返回新的 Array Iterator 对象，包含数组中每个下标处的值。")属性的初始值相同的对象。 

513 | [get TypedArray[@@species]]3614 "") | **** 
`**TypedArray[@@species]**`访问器属性返回[类型化数组]3620 "")的构造器。 

514 | [URIError]40565 "") | **** 
URIError 对象用来表示以一种错误的方式使用全局URI处理函数而产生的错误。 

515 | [Uint32Array]3609 "") | **** 
**`Uint32Array`**表示一个由基于平台字节序的32位无符号字节组成的数组.如果需要对字节顺序进行控制(译者注:即 littleEndian 或 bigEndian),请使用[`DataView`]3684 "DataView视图提供了一个与平台中字节在内存中的排列顺序(字节序)无关的从ArrayBuffer读写多数字类型的底层接口.")代替.数组中每个元素的初始值都是0.一旦创建，你可以用对象的方法引用数组里的元素，或者使用标准的数组索引语法（即，使用中括号）。 

516 | [Uint8Array]3605 "") | **** 
**`Uint8Array`**数组类型表示一个8位无符号整型数组，创建时内容被初始化为0。创建完后，可以以对象的方式或使用数组下标索引的方式引用数组中的元素。 

517 | [Uint8ClampedArray]371 "") | **** 
**`Uint8ClampedArray`（8位无符号整型固定数组）**类型化数组表示一个由值固定在0-255区间的8位无符号整型组成的数组；如果你指定一个在 [0,255] 区间外的值，它将被替换为0或255；如果你指定一个非整数，那么它将被设置为最接近它的整数。（数组）内容被初始化为0。一旦（数组）被创建，你可以使用对象的方法引用数组里的元素，或使用标准的数组索引语法（即使用方括号标记）。 

518 | [WeakMap]40566 "") | **ECMAScript6, JavaScript, WeakMap** 
**`WeakMap`**对象是一组键/值对的集合，且其中的键是弱引用的。键必须是对象，值可以是任意值。 

519 | [WeakMap.prototype]42752 "") | **** 
`**WeakMap**`**`.prototype`**属性表现为[`WeakMap`]40775 "此页面仍未被本地化, 期待您的翻译!")的构造器。 

520 | [WeakMap.prototype.clear()]42753 "") | **JavaScript, Method, WeakMap, clear()** 
`**clear()**`用来从`WeakMap对象中移除所有元素。`但不再是ECMAScript和它的实现部分。 

521 | [WeakMap.prototype.delete()]42754 "") | **** 
`**delete()**`方法可以从一个`WeakMap`对象中删除指定的元素。 

522 | [WeakMap.prototype.get()]42755 "") | **** 
`**get()**`方法返回`WeakMap`指定的元素。 

523 | [WeakMap.prototype.has()]42756 "") | **** 
`**has()**`方法根据WeakMap对象的元素中是否存在key键返回一个boolean值。 

524 | [WeakMap.prototype.set()]42757 "") | **** 
`**set()**`方法根据指定的`key和``value在``WeakMap对象中添加新/更新元素。` 

525 | [WeakSet]40567 "") | **WeakSet** 
**`WeakSet`**对象允许你将*弱保持对象*存储在一个集合中。 

526 | [WeakSet.prototype]42768 "") | **** 
The`**WeakSet**`**`.prototype`**property represents the prototype for the[`WeakSet`]40567 "一个 WeakSet 对象是一个无序的集合, 可以用它来存储任意的对象值, 并且对这些对象值保持弱引用.")constructor. 

527 | [WeakSet.prototype.add()]42769 "") | **** 
`**add()**`方法在`WeakSet`对象的最后一个元素后添加新的对象。 

528 | [WeakSet.prototype.clear()]42770 "") | **JavaScript, Method, WeakSet, 废弃** 
`**clear()**`方法用于删除`WeakSet`对象的所有元素，但是已经不是 ECMAScript 的一部分了。 

529 | [WeakSet.prototype.delete()]42771 "") | **** 
`**delete()**`方法从`WeakSet 对象中`移除指定的元素。 

530 | [WeakSet.prototype.has()]42772 "") | **** 
`**has()**`方法根据`WeakSet`是否存在相应对象返回布尔值。 

531 | [WebAssembly]40568 "") | **** 
**`WebAssembly`**JavaScript 对象是所有[WebAssembly]21620 "")相关功能的命名空间。 

532 | [WebAssembly.Instance]41666 "") | **API, Experimental, JavaScript, Reference, WebAssembly** 
A**`WebAssembly.Instance`**object is a stateful, executable instance of a[WebAssembly.Module]42784 "").`Instance`objects contain all the[Exported WebAssembly functions]42786 "")that allow calling into WebAssembly code from JavaScript. 

533 | [WebAssembly.compile()]42776 "") | **** 
**`WebAssembly.compile()`**方法编译WebAssembly二进制代码到一个[`WebAssembly.Module`]41665 "此页面仍未被本地化, 期待您的翻译!")对象。如果在实例化之前有必要去编译一个模块，那么这个方法是有用的（否则，将会使用[`WebAssembly.instantiate()`]42779 "WebAssembly.instantiate() 是编译和实例化 WebAssembly 代码的主要方法.  这个方法有两个重载方式:")方法） 

534 | [WebAssembly.instantiate()]42779 "") | **** 
**`WebAssembly.instantiate()`**是编译和实例化 WebAssembly 代码的主要方法. 这个方法有两个重载方式: 

535 | [decodeURI()]40569 "") | **JavaScript, URI, decodeURI(), 统一资源标识符** 
`**decodeURI()**`函数解码一个由[`encodeURI`]39937 "encodeURI()  函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码 (该字符的 UTF-8 编码仅为四转义序列)由两个 "代理" 字符组成)。")先前创建的统一资源标识符（URI）或类似的例程。 

536 | [decodeURIComponent()]40570 "") | **JavaScript, URI, 统一资源标识符, 解码** 
`**decodeURIComponent()**`方法用于解码由[`encodeURIComponent`]40571 "encodeURIComponent()是对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码（只有由两个Unicode代理区字符组成的字符才用四个转义字符编码）。")方法或者其它类似方法编码的部分统一资源标识符（URI）。 

537 | [encodeURI()]39937 "") | **JavaScript, URI, decodeURI, encodeURI, 统一资源定位符** 
`**encodeURI()**`函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码 (该字符的 UTF-8 编码仅为四转义序列)由两个 &quot;代理&quot; 字符组成)。 

538 | [encodeURIComponent()]40571 "") | **JavaScript, URI, 统一资源标识符** 
`**encodeURIComponent()**`是对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码（只有由两个Unicode代理区字符组成的字符才用四个转义字符编码）。 

539 | [escape()]40572 "") | **** 
废弃的`**escape()**`方法生成新的由十六进制转义序列替换的字符串. 使用[`encodeURI`]39937 "encodeURI() 是对统一资源标识符（URI）进行编码的方法。它使用1到4个转义序列来表示每个字符的UTF-8编码（只有由两个代理字符区组成的字符才用四个转义字符编码）。")或[`encodeURIComponent`]40571 "encodeURIComponent()是对统一资源标识符（URI）的组成部分进行编码的方法。它使用一到四个转义序列来表示字符串中的每个字符的UTF-8编码（只有由两个Unicode代理区字符组成的字符才用四个转义字符编码）。")代替. 

540 | [eval()]40573 "") | **JavaScript, eval** 
执行指定代码之后的返回值。如果返回值为空，返回[`undefined`]23495 "undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。") 

541 | [isFinite()]40574 "") | **JavaScript, isFinite** 
该全局 isFinite() 函数用来判断被传入的参数值是否为一个有限数值（finite number）。在必要情况下，参数会首先转为一个数值。 

542 | [isNaN()]40575 "") | **JavaScript** 
`**isNaN()**`函数用来确定一个值是否为[`NaN`]23642 "全局属性 NaN 表示 Not-A-Number 的值。")。注：`isNaN`函数内包含一些非常有趣的[规则]44211 "")；你也可以通过ECMAScript 2015/ES6 中定义的[`Number.isNaN()`]41206 "Number.isNaN() 方法用来检测传入的值是否是 NaN。该方法比传统的全局函数 isNaN() 更可靠。")或者 可以使用`[typeof]40910 "")`来判断该值是否为一个非数字。 

543 | [null]4768 "") | **JavaScript, Literal, Primitive** 
值`null`是一个 JavaScript 字面量，表示空值（null or an &quot;empty&quot; value），即没有对象被呈现（no object value is present）。它是 JavaScript[原始值]41155 "原始值: A primitive (primitive value, primitive data type) is data that is not an object and has no methods. In JavaScript, there are 6 primitive data types: string, number, boolean, null, undefined, symbol (new in ECMAScript 2015).")之一。 

544 | [parseFloat]40576 "") | **parseFloat()** 
**parseFloat()**函数解析一个字符串参数并返回一个浮点数。 

545 | [parseInt]40577 "") | **JavaScript, parseInt()** 
**parseInt()**函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。 

546 | [undefined]23495 "") | **** 
`undefined`是全局对象的一个属性。也就是说，它是全局作用域的一个变量。`undefined`的最初值就是原始数据类型`[undefined]41508 "undefined: A primitive value automatically assigned to variables that have just been declared or to formal arguments for which there are no actual arguments.")`。 

547 | [unescape()]40578 "") | **JavaScript** 
`**unescape()**`方法计算生成一个新的字符串，其中的十六进制转义序列将被其表示的字符替换。上述的转义序列就像[`escape`]40572 "废弃的 escape() 方法生成新的由十六进制转义序列替换的字符串. 使用 encodeURI 或 encodeURIComponent 代替.")里介绍的一样。因为`unescape`已经废弃，建议使用[`decodeURI`]40569 "decodeURI() 函数解码一个由encodeURI 先前创建的统一资源标识符（URI）或类似的例程。")或者[`decodeURIComponent`]40570 "decodeURIComponent() 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）。")替代本方法。 

548 | [uneval()]40579 "") | **JavaScript** 
`**uneval()**`函数创建一个代表对象的源代码的字符串。 

549 | [JavaScript 错误参考]40656 "") | **Debugging, Errors, JavaScript, 调试, 错误** 
下面列出了 JavaScript 抛出的错误。这些错误是有用的调试帮助，但报告的问题并不总是十分明了。下面的页面提供有关这些错误的详细信息。每个错误都是基于[`Error`]10494 "通过Error的构造器可以创建一个错误对象。当运行时错误产生时，Error的实例对象会被抛出。Error对象可用于用户自定义的异常的基础对象。下面列出了各种内建的标准错误类型。")的对象，并且具有名称和消息。 

550 | [Error: Permission denied to access property &quot;x&quot;]40657 "") | **Error, Permission denied, 错误** 
[`错误`]10494 "通过Error的构造器可以创建一个错误对象。当运行时错误产生时，Error的实例对象会被抛出。Error对象可用于用户自定义的异常的基础对象。下面列出了各种内建的标准错误类型。"). 

551 | [InternalError: too much recursion]40658 "") | **InternalError, recursion, 内部错误** 
[`内部错误`]40529 "InternalError 对象表示出现在JavaScript引擎内部的错误。 例如： "InternalError: too much recursion"（内部错误：递归过深）。"). 

552 | [RangeError: argument is not a valid code point]40659 "") | **** 
[`RangeError`]22962 "RangeError对象标明一个错误，当一个值不在其所允许的范围或者集合中。") 

553 | [RangeError: invalid array length]40660 "") | **JavaScript, 范围错误, 错误** 
[`RangeError`]22962 "RangeError对象标明一个错误，当一个值不在其所允许的范围或者集合中。") 

554 | [RangeError: invalid date]40661 "") | **JavaScript, 范围错误, 错误** 
[`RangeError`]22962 "RangeError对象标明一个错误，当一个值不在其所允许的范围或者集合中。") 

555 | [RangeError: precision is out of range]40662 "") | **JavaScript, 范围错误, 错误** 
[`RangeError`]22962 "RangeError对象标明一个错误，当一个值不在其所允许的范围或者集合中。") 

556 | [RangeError: radix must be an integer]40663 "") | **JavaScript, 范围错误, 错误** 
[`RangeError`]22962 "RangeError对象标明一个错误，当一个值不在其所允许的范围或者集合中。") 

557 | [RangeError: repeat count must be less than infinity]40664 "") | **Errors, JavaScript, RangeError, 错误** 
[`RangeError`]22962 "RangeError对象标明一个错误，当一个值不在其所允许的范围或者集合中。") 

558 | [RangeError: repeat count must be non-negative]40665 "") | **Errors, JavaScript, RangeError, 错误** 
[`RangeError`]22962 "RangeError对象标明一个错误，当一个值不在其所允许的范围或者集合中。") 

559 | [ReferenceError: &quot;x&quot; is not defined]40666 "") | **** 
[`ReferenceError`]40538 "ReferenceError（引用错误） 对象表明一个不存在的变量被引用。"). 

560 | [ReferenceError: assignment to undeclared variable &quot;x&quot;]40667 "") | **Errors, JavaScript, ReferenceError, 严格模式, 错误** 
仅在[严格模式]23201 "")中出现[`ReferenceError`]40538 "ReferenceError（引用错误） 对象表明一个不存在的变量被引用。")警告。 

561 | [ReferenceError: can&#39;t access lexical declaration`X&#39; before initialization]40668 "") | **JavaScript, 错误提示** 
[`ReferenceError`]40538 "ReferenceError（引用错误） 对象表明一个不存在的变量被引用。") 

562 | [ReferenceError: deprecated caller or arguments usage]40669 "") | **Errors, JavaScript, Strict Mode, 严格模式, 警告** 
仅在严格模式下出现的[`ReferenceError`]40538 "ReferenceError（引用错误） 对象表明一个不存在的变量被引用。")警告。JavaScript 的执行将不会停止。 

563 | [ReferenceError: invalid assignment left-hand side]40670 "") | **Errors, JavaScript, ReferenceError** 
[`ReferenceError`]40538 "ReferenceError（引用错误） 对象表明一个不存在的变量被引用。"). 

564 | [ReferenceError: reference to undefined property &quot;x&quot;]40671 "") | **Errors, JavaScript, ReferenceError, Strict Mode, 严格模式** 
仅在[strict mode]23201 "")下出现[`ReferenceError`]40538 "ReferenceError（引用错误） 对象表明一个不存在的变量被引用。")警告。 

565 | [SyntaxError: &quot;0&quot;-prefixed octal literals and octal escape seq. are deprecated]40672 "") | **JavaScript, 严格模式, 语法错误, 错误提示** 
语法错误（[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。")），只出现于[严格模式]40821 "")下。 

566 | [SyntaxError: &quot;use strict&quot; not allowed in function with non-simple parameters]40673 "") | **Errors, JavaScript, SyntaxError, TypeError, use strict** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。"). 

567 | [SyntaxError: &quot;x&quot; is a reserved identifier]40674 "") | **JavaScript, 语法错误, 错误** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

568 | [SyntaxError: &quot;x&quot; is not a legal ECMA-262 octal constant]40725 "") | **Errors, JavaScript, SyntaxError, 严格模式** 
仅在[strict mode]23201 "")下出现[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。")警告。 

569 | [SyntaxError: JSON.parse: bad parsing]40675 "") | **Errors, JSON, JavaScript, SyntaxError, 方法** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

570 | [SyntaxError: Malformed formal parameter]40676 "") | **Errors, JavaScript, SyntaxError** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

571 | [SyntaxError: Unexpected token]40677 "") | **Errors, JavaScript, SyntaxError** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

572 | [SyntaxError: Using //@ to indicate sourceURL pragmas is deprecated. Use //# instead]40678 "") | **Errors, JavaScript, Source maps** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。")的警告。不会终止 JavaScript 的执行。 

573 | [SyntaxError: a declaration in the head of a for-of loop can&#39;t have an initializer]40679 "") | **JavaScript, 语法错误, 错误提示** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

574 | [SyntaxError: applying the &#39;delete&#39; operator to an unqualified name is deprecated]40680 "") | **JavaScript, 语法错误, 错误提示** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。")仅出现在[严格模式]40821 "")下。 

575 | [SyntaxError: for-in loop head declarations may not have initializers]40681 "") | **JavaScript, 严格模式, 语法错误** 
该[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。")只出现于[严格模式]40821 "")下。 

576 | [SyntaxError: function statement requires a name]40682 "") | **JavaScript, 语法错误, 错误提示** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

577 | [SyntaxError: identifier starts immediately after numeric literal]40683 "") | **** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

578 | [SyntaxError: illegal character]40684 "") | **JavaScript, 语法错误** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

579 | [SyntaxError: invalid regular expression flag &quot;x&quot;]40685 "") | **语法错误, 错误** 
[`语法错误`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。"). 

580 | [SyntaxError: missing ) after argument list]40686 "") | **JavaScript, 语法错误, 错误** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。"). 

581 | [SyntaxError: missing ) after condition]40687 "") | **JavaScript, 语法错误, 错误** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

582 | [SyntaxError: missing : after property id]40688 "") | **JavaScript, 语法错误, 错误提示** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

583 | [SyntaxError: missing ; before statement]40689 "") | **** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。"). 

584 | [SyntaxError: missing = in const declaration]40690 "") | **JavaScript, 语法错误, 错误提示** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

585 | [SyntaxError: missing ] after element list]40691 "") | **Errors, JavaScript, SyntaxError** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。"). 

586 | [SyntaxError: missing formal parameter]40692 "") | **JavaScript, 类型错误, 错误, 错误提示** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

587 | [SyntaxError: missing name after . operator]40693 "") | **JavaScript, 语法错误, 错误提示** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

588 | [SyntaxError: missing variable name]40694 "") | **JavaScript, 语法错误, 错误提示** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

589 | [SyntaxError: missing } after function body]40695 "") | **JavaScript, 语法错误, 错误提示** 
[`SyntaxError`]43494 "此页面仍未被本地化, 期待您的翻译!") 

590 | [SyntaxError: missing } after property list]40696 "") | **Errors, JavaScript, SyntaxError** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

591 | [SyntaxError: redeclaration of formal parameter &quot;x&quot;]40697 "") | **Errors, JavaScript, SyntaxError** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

592 | [SyntaxError: return not in function]40698 "") | **** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。"). 

593 | [SyntaxError: test for equality (==) mistyped as assignment (=)?]40699 "") | **语法错误** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。")只在[严格模式]40821 "")下会出现的警告。 

594 | [SyntaxError: unterminated string literal]40700 "") | **Error, JavaScript, SyntaxError** 
[`SyntaxError`]40564 "SyntaxError 对象代表尝试解析语法上不合法的代码的错误。") 

595 | [TypeError: &quot;x&quot; has no properties]40701 "") | **** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。"). 

596 | [TypeError: &quot;x&quot; is (not) &quot;y&quot;]40702 "") | **类型错误** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。"). 

597 | [TypeError: &quot;x&quot; is not a constructor]40703 "") | **Errors, JavaScript, TypeError** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。") 

598 | [TypeError: &quot;x&quot; is not a function]40704 "") | **Errors, JavaScript, TypeError** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。") 

599 | [TypeError: &quot;x&quot; is not a non-null object]40705 "") | **JavaScript, 类型错误, 错误提示** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。") 

600 | [TypeError: &quot;x&quot; is read-only]40706 "") | **** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。") 

601 | [TypeError: More arguments needed]40708 "") | **Errors, JavaScript, TypeError** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。"). 

602 | [TypeError: can&#39;t access dead object]40710 "") | **JavaScript, 插件, 错误提示** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。") 

603 | [TypeError: can&#39;t define property &quot;x&quot;: &quot;obj&quot; is not extensible]40711 "") | **Error, Errors, JavaScript, TypeError, 类型错误, 错误提示** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。") 

604 | [TypeError: can&#39;t delete non-configurable array element]40712 "") | **JavaScript, 错误提示** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。") 

605 | [TypeError: can&#39;t redefine non-configurable property &quot;x&quot;]40713 "") | **JavaScript, 类型错误, 错误提示** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。") 

606 | [TypeError: cyclic object value]40715 "") | **Error, JavaScript, 类型错误, 错误提示** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。") 

607 | [TypeError: invalid &#39;in&#39; operand &quot;x&quot;]40714 "") | **JavaScript, 类型错误, 错误提示** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。") 

608 | [TypeError: invalid Array.prototype.sort argument]40717 "") | **Errors, JavaScript, TypeError** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。") 

609 | [TypeError: invalid arguments]40718 "") | **JavaScript, 类型错误, 错误提示** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。") 

610 | [TypeError: invalid assignment to const &quot;x&quot;]40719 "") | **JavaScript, 类型错误, 错误提示** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。") 

611 | [TypeError: property &quot;x&quot; is non-configurable and can&#39;t be deleted]40720 "") | **JavaScript, 严格模式, 类型错误, 错误** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。")只出现在严格模式下。 

612 | [TypeError: setting getter-only property &quot;x&quot;]40721 "") | **JavaScript, 严格模式, 类型错误, 错误提示** 
仅在[严格模式]40821 "")下报[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。")错误。 

613 | [TypeError: variable &quot;x&quot; redeclares argument]40722 "") | **** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。")警告仅仅在[严格模式下]40821 "")出现。 

614 | [URIError: malformed URI sequence]40723 "") | **JavaScript, URLError, 错误提示** 
[`URIError`]40565 "URIError 对象用来表示以一种错误的方式使用全局URI处理函数而产生的错误。") 

615 | [Warning: -file- is being assigned a //# sourceMappingURL, but already has one]40724 "") | **** 
一个警告。JavaScript 的执行不会中止。 

616 | [Warning: Date.prototype.toLocaleFormat is deprecated]40726 "") | **JavaScript, 警告** 
警告。JavaScript 引擎不会停止运行。 

617 | [Warning: JavaScript 1.6&#39;s for-each-in loops are deprecated]40727 "") | **Warning** 
警告 

618 | [Warning: String.x is deprecated; use String.prototype.x instead]40728 "") | **JavaScript, 警告** 
警告。JavaScript 引擎不会停止运行。 

619 | [Warning: expression closures are deprecated]40729 "") | **JavaScript, 警告** 
警告。JavaScript 引擎不会停止运行。 

620 | [Warning: unreachable code after return statement]40730 "") | **警告** 
警告 

621 | [X.prototype.y called on incompatible type]40731 "") | **JavaScript, 类型错误** 
[`TypeError`]3682 "TypeError（类型错误） 对象用来表示值的类型非预期类型时发生的错误。") 

622 | [Reserved Words]44212 "") | **** 
**No summary!** 

623 | [Statements and declarations(语句)]40614 "") | **参考, 语句** 
JavaScript 应用程序是由许多语法正确的语句组成的。单个语句可以跨多行。如果每个语句用分号隔开，那么多个语句可以在一行中出现。本页的内容并不是一个关键字，而是一组关键字。 

624 | [async function]40616 "") | **Function, JavaScript, Statement** 
调用`async`函数时会返回一个[`Promise`]4107 "Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义：诺言，一个成功，一个失败。)")对象。当这个`async`函数返回一个值时，`Promise`的 resolve 方法将会处理这个值；当`async`函数抛出异常时，`Promise`的 reject 方法将处理这个异常值。 

625 | [block]40617 "") | **JavaScript, Reference, Statement** 
**块语句**（或其他语言的**复合语句**）用于组合零个或多个语句。该块由一对大括号界定，可以是[`labelled`]40636 "标记语句可以和 break 或 continue 语句一起使用。标记就是在一条语句前面加个可以引用的标识符。")： 

626 | [break]40618 "") | **JavaScript, Statement** 
**break 语句**中止当前循环，[`switch`]40639 "switch 语句评估一个表达式，将表达式的值与case子句匹配，并执行与该情况相关联的语句。")语句或[`label`]40636 "标记语句可以和 break 或 continue 语句一起使用。标记就是在一条语句前面加个可以引用的标识符。")语句，并把程序控制流转到紧接着被中止语句后面的语句。 

627 | [class]40619 "") | **Class, Classes, Declaration, ECMAScript 2015, ES6, JavaScript, Reference, Statement** 
**class 声明**创建一个基于原型继承的具有给定名称的新类。 

628 | [const]40620 "") | **ECMAScript 2015, JavaScript, Reference, Statement, constants** 
常量是块级作用域，很像使用[let]40637 "")语句定义的变量。常量的值不能通过重新赋值来改变，并且不能重新声明。 

629 | [continue]40621 "") | **** 
**continue 语句**结束当前（或标签）的循环语句的本次迭代，并继续执行循环的下一次迭代。 

630 | [debugger]40622 "") | **JavaScript, Statement** 
**debugger 语句**调用任何可用的调试功能，例如设置断点。 如果没有调试功能可用，则此语句不起作用。 

631 | [default]40623 "") | **JavaScript, Keyword** 
**default 关键字**可以在 JavaScript 的两种情况下使用：在[`switch`]40639 "switch 语句评估一个表达式，将表达式的值与case子句匹配，并执行与该情况相关联的语句。")，或[`export`]40626 "有两种不同的导出方式，每种方式对应于上述的一种语法：")中。 

632 | [do...while]40624 "") | **JavaScript, Statement** 
**`do...while`语句**创建一个执行指定语句的循环，直到`condition`值为 false。在执行`statement`后检测`condition`，所以指定的`statement`至少执行一次。 

633 | [empty]40625 "") | **JavaScript, Statement** 
**空语句**用来表明没有语句，尽管 JavaScript 语法希望有语句。 

634 | [export]40626 "") | **ECMAScript 2015, JavaScript, Modules, Statement, export** 
有两种不同的导出方式，每种方式对应于上述的一种语法： 

635 | [for]40627 "") | **JavaScript, Loop, Reference, Statement, for** 
**`for 语句`**用于创建一个循环，它包含了三个可选的表达式，三个可选的表达式包围在圆括号中并由分号分隔，后跟一个在循环中执行的语句（通常是一个[块语句]40617 "")）。 

636 | [for each...in]40628 "") | **** 
使用一个变量迭代一个对象的所有属性值,对于每一个属性值,有一个指定的语句块被执行. 

637 | [for...in]40629 "") | **JavaScript, Statement** 
**`for...in`语句**以任意顺序遍历一个对象的[可枚举属性]40734 "")。对于每个不同的属性，语句都会被执行。 

638 | [for...of]13613 "") | **ECMAScript 2015, JavaScript, Reference, Statement** 
**`for...of`语句**在[可迭代对象]43264 "")（包括[`Array`]6708 "entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。")，[`Map`]40774 "此页面仍未被本地化, 期待您的翻译!")，[`Set`]40561 "Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。")，[`String`]4402 "此页面仍未被本地化, 期待您的翻译!")，[`TypedArray`]5141 "一个TypedArray 对象描述一个底层的二进制数据缓存区的一个类似数组(array-like)视图。没有名为 TypedArray的全局属性，也没有一个直接可见的 TypedArray构造函数。相反，有许多不同的全局属性，其值是下面列出的特定元素类型的类型化数组构造函数。在下面的页面中，你会找到可用于包含任何类型的元素的任何类型数组的常见属性和方法")，[arguments]41194 "")对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。 

639 | [function]40630 "") | **函数, 函数声明提升, 函数表达式, 提升, 语句** 
**函数声明**定义一个具有指定参数的函数。 

640 | [function*]40631 "") | **ECMAScript 2015, Generator, JavaScript, function*, 函数, 声明, 迭代器** 
`**function***`这种声明方式(`function`关键字后跟一个星号）会定义一个***生成器函数*(***generator function***)**，它返回一个[`Generator`]40527 "生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。")对象。 

641 | [if...else]40632 "") | **JavaScript, Statement** 
当指定条件为真，**if 语句**会执行一段语句。如果条件为假，则执行另一段语句。 

642 | [import]40633 "") | **ECMAScript 2015, JavaScript, Modules, Statement, import** 
`**import**`语句用于导入由另一个模块导出的绑定。 

643 | [label]40636 "") | **JavaScript, Statement** 
**标记语句**可以和[`break`]40618 "break 语句中止当前循环，switch语句或label 语句，并把程序控制流转到紧接着被中止语句后面的语句。")或[`continue`]40621 "continue 语句结束当前（或标签）的循环语句的本次迭代，并继续执行循环的下一次迭代。")语句一起使用。标记就是在一条语句前面加个可以引用的标识符。 

644 | [let]40637 "") | **ECMAScript 2015, JavaScript, Statement, Variable declaration, Variables, let** 
**`let`**允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与[var]40642 "")关键字不同的是，它声明的变量只能是全局或者整个函数块的。 

645 | [return]40638 "") | **JavaScript, Statement** 
**`return`语句**终止函数的执行，并返回一个指定的值给函数调用者。 

646 | [switch]40639 "") | **JavaScript, Reference, Statement, Web** 
**`switch`语句**评估一个[表达式]40500 "")，将表达式的值与`case`子句匹配，并执行与该情况相关联的[语句]40614 "")。 

647 | [throw]40640 "") | **JavaScript, Statement** 
**`throw`语句**用来抛出一个用户自定义的异常。当前函数的执行将被停止（`throw`之后的语句将不会执行），并且控制将被传递到调用堆栈中的第一个[`catch`]40641 "")块。如果调用者函数中没有`catch`块，程序将会终止。 

648 | [try...catch]40641 "") | **Error, Exception, JavaScript, Statement** 
**`try...catch`**语句将能引发错误的代码放在try块中，并且对应一个响应，然后有异常被抛出。 

649 | [var]40642 "") | **JavaScript, Statement** 
**`variable`语句**声明了一个变量，可选地将其初始化为一个值。 

650 | [while]40643 "") | **JavaScript, Statement** 
**while 语句**可以在某个条件表达式为真的前提下，循环执行指定的一段代码，直到那个表达式不为真时结束循环。 

651 | [with]40644 "") | **Deprecated, JavaScript, Statement** 
JavaScript查找某个未使用命名空间的变量时，会通过作用域链来查找，作用域链是跟执行代码的context或者包含这个变量的函数有关。&#39;with&#39;语句將某个对象添加的作用域链的顶部，如果在statement中有某个未使用命名空间的变量，跟作用域链中的某个属性同名，则这个变量将指向这个属性值。如果沒有同名的属性，则将拋出[`ReferenceError`]40538 "ReferenceError（引用错误） 对象表明一个不存在的变量被引用。")异常。 

652 | [遗留的生成器函数]40615 "") | **** 
**遗留的生成器函数语句**使用特殊参数声明遗留的生成器函数。 

653 | [严格模式]23201 "") | **JavaS, Strict Mode, 严格模式** 
如果你想改变你的代码，让其工作在JavaScript的限制变体, 请参阅[转换成严格模式]41034 "")。 

654 | [向严格模式过渡]40735 "") | **** 
ECMAScript 5 引入了[strict mode]43616 "/zh-CN/docs/JavaScript/Strict_mode"),现在已经被大多浏览器实现(包括IE10. 会使web浏览器更容易的解析代码(只需要添加`"use strict";`在源码的最上面), 由现有的代码到严格模式的过渡需要一些事做. 

655 | [关于该参考]41657 "") | **JavaScript** 
该JavaScript参考提供Javascript语言的知识仓库。 详细的描述了完整的Javascript语言的信息。如果你编写JavaScript代码， 你会经常使用这些页面 (因此标题为 &quot;JavaScript参考文档&quot;)。如果你正在学习JavaScript， 或需要帮助理解一些Javascript的功能或特性, 请查看[JavaScript指南]40495 "")。 

656 | [函数]40645 "") | **Function, Functions, JavaScript, 函数声明** 
有关更多示例和说明，请参阅[有关函数的JavaScript指南]23189 "")。 

657 | [Arguments 对象]40646 "") | **Functions, JavaScript, Reference, arguments** 
**`arguments`**是一个对应于传递给函数的参数的类数组对象。 

658 | [arguments.callee]43372 "") | **Deprecated, JavaScript, arguments, arguments.callee, 函数, 属性, 已弃用** 
`**arguments.callee**`属性包含当前正在执行的函数。 

659 | [arguments.length]43374 "") | **** 
本次函数调用时传入函数的实参数量. 

660 | [arguments[@@iterator]()]43647 "") | **** 
`**@@iterator**`属性的初始值是和[`Array.prototype.values`]3669 "values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。")属性的初始值相同的对象。 

661 | [caller]43373 "") | **** 
`**arguments.caller**`属性原先用在函数执行的时候调用自身。本属性已被移除且不再有用。 

662 | [getter]40650 "") | **ECMAScript 2015, Functions, JavaScript** 
**`get`**语法将对象属性绑定到查询该属性时将被调用的函数。 

663 | [setter]40651 "") | **ECMAScript 5, Functions, JavaScript** 
当尝试设置属性时，**`set`**语法将对象属性绑定到要调用的函数。 

664 | [剩余参数]40649 "") | **Functions, JavaScript, Rest, Rest parameters** 
**剩余参数**语法允许我们将一个不定数量的参数表示为一个数组。 

665 | [方法的定义]40648 "") | **ECMAScript 2015, Functions, JavaScript, Object, Syntax** 
从ECMAScript 2015开始，在对象初始器中引入了一种更简短定义方法的语法，这是一种把方法名直接赋给函数的简写方式。 

666 | [箭头函数]25026 "") | **ECMAScript 2015, ES6 Arrow Function, Functions, Intermediate, JavaScript, Lambda, Lambda Expression, Reference, ramda** 
**箭头函数表达式**的语法比[函数表达式]40603 "")更短，并且不绑定自己的[this]40609 "")，[arguments]40646 "")，[super]40608 "")或[new.target]40607 "")。这些函数表达式最适合用于非方法函数，并且它们不能用作构造函数。 

667 | [默认参数值]40647 "") | **ECMAScript 2015, Functions, JavaScript** 
**函数默认参数**允许在没有值或`undefined`被传入时使用默认形参。 

668 | [尾后逗号]44213 "") | **** 
**尾后逗号**（有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。 这使得版本控制的比较更加清晰，以及代码便器的麻烦更少。 

669 | [废弃和过时的JavaScript特性]40736 "") | **** 
本附录列出了那些已经被废弃的(仍然可用,但未来会被删除)或者已经过时的(已经被删除,不能再用了)JavaScript特性. 

670 | [?原始迭代协议]44214 "") | **JavaScript, Legacy Iterator, 传统迭代协议, 废弃属性** 
Firefox在version 26版本生效的与[ES2015迭代协议]13616 "")相似的另一种迭代协议。以下统称为旧迭代协议。 

671 | [模板字符串]44209 "") | **ECMAScript6, JavaScript, Template string, 模板字符串** 
模板字面量/Template literals 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串/template strings”。 

672 | [类]40652 "") | **Class, Classes, ECMAScript 2015, JavaScript, maximally-minimal-classes, 基于原型的继承, 构造器, 类, 类声明和类表达式, 语法糖** 
ECMAScript 2015 中引入的 JavaScript 类(`classes`) 实质上是 JavaScript 现有的基于原型的继承的语法糖。 类语法不是向JavaScript引入一个新的面向对象的继承模型。JavaScript类提供了一个更简单和更清晰的语法来创建对象并处理继承。 

673 | [extends]40654 "") | **Classes, ECMAScript 2015, JavaScript** 
**`extends`**关键字用于[类声明]40619 "")或者[类表达式]40601 "")中，以创建一个类，该类是另一个类的子类。 

674 | [static]40655 "") | **Classes, ECMAScript 2015, ES6, JavaScript, Static, 静态方法** 
**static**关键字为一个类定义了一个静态方法。 

675 | [构造方法]40653 "") | **Class, Classes, ECMAScript 2015, ES6, JavaScript, Modules, OOP, component** 
**构造函数`constructor`**是用于创建和初始化类中创建的一个对象的一种特殊方法。 

676 | [表达式和运算符]40580 "") | **JavaScript, 操作符** 
左侧工具栏是按字母表排序的列表。 

677 | [Expression closures]40589 "") | **Functions, JavaScript, Reference** 
表达式闭包是定义简单函数的一种便捷方式。 

678 | [Generator推导式]40590 "") | **** 
生成器推导语法是一种JavaScript表达式，它允许您基于现有的可迭代对象快速组合新的生成器函数。 

679 | [Property accessors]40597 "") | **JavaScript, Operator** 
属性访问器提供了两种方式用于访问一个对象的属性，它们分别是点号和方括号。 

680 | [async function expression]40599 "") | **JavaScript, async function expression, 函数, 基本表达式, 实验性, 操作符** 
**`async function`**关键字可以用来定义一个异步函数表达式。 

681 | [await]40600 "") | **JavaScript, Promise, await, 实验性, 操作符** 
`await`操作符用于等待一个[`Promise`]4107 "Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义：诺言，一个成功，一个失败。)")对象。它只能在异步函数[`async function`]40616 "调用 async 函数时会返回一个 Promise 对象。当这个 async 函数返回一个值时，Promise 的 resolve 方法将会处理这个值；当 async 函数抛出异常时，Promise 的 reject 方法将处理这个异常值。")中使用。 

682 | [delete]40602 "") | **JavaScript, Operator, Reference, Unary, 一元, 操作符** 
**`delete`操作符**用于删除对象的某个属性。 

683 | [function* expression]40604 "") | **ECMAScript6** 
Editorial review completed. 

684 | [in]40605 "") | **JavaScript, Operator, Relational Operators** 
如果指定的属性在指定的对象或其原型链中，则**`in`运算符**返回`true`。 

685 | [instanceof]40606 "") | **JavaScript, Object, Prototype, instanceof, 原型, 对象** 
`**instanceof**`**运算符**用来测试一个对象在其原型链中是否存在一个构造函数的`prototype`属性。 

686 | [new.target]40607 "") | **Classes, ECMAScript 2015, JavaScript, Reference** 
`new.target`语法由一个关键字&quot;`new`&quot;，一个点，和一个属性名&quot;&quot;组成。通常&quot;`new.`&quot;`的`作用是提供属性访问的上下文，但这里&quot;`new.`&quot;其实不是一个真正的对象。不过在构造方法调用中，`new.target`指向被`new`调用的构造函数，所以&quot;`new.`&quot;成为了一个虚拟上下文。 

687 | [new运算符]22979 "") | **JavaScript, Left-hand-side expressions, Operator** 
**`new`运算符**创建一个自定义对象或具有构造函数的内置对象的实例。 

688 | [super]40608 "") | **Classes, ECMAScript 2015, JavaScript, Operator** 
**super**关键字用于访问和调用一个对象的父对象上的函数。 

689 | [this]40609 "") | **JavaScript, Operator, this, 参考, 基本表达式, 操作符** 
与其他语言相比，**函数的`this`关键字**在JavaScript中的表现略有不同，此外，在**[严格模式]44215 "")**和**非严格模式**之间也会有一些差别。 

690 | [typeof]40610 "") | **JavaScript, Operator, Unary** 
**`typeof`**操作符返回一个字符串，指示未经计算的操作数的类型。 

691 | [void 运算符]40611 "") | **JavaScript, Unary** 
**`void`运算符**对给定的表达式进行求值，然后返回[`undefined`]23495 "undefined是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined的最初值就是原始数据类型undefined。")。 

692 | [yield]40612 "") | **ES5, Generators, yield** 
`yield`关键字用来暂停和恢复一个生成器函数 ( ([`function*`]40631 "function* 这种声明方式(function关键字后跟一个星号）会定义一个生成器函数 (generator function)，它返回一个  Generator  对象。")或[legacy generator]44216 "/zh-CN/docs/JavaScript/Guide/Iterators_and_Generators")). 

693 | [yield*]40613 "") | **ECMAScript6, Experimental, Expérimental, Generators, Iterable, Iterator, JavaScript, Operator, Reference, Référence** 
**No summary!** 

694 | [函数表达式]40603 "") | **Function, JavaScript, 函数, 基本表达式, 操作符** 
**`function`**关键字可以用来在一个表达式中定义一个函数。 

695 | [圆括号运算符]40591 "") | **** 
`( )`用来控制表达式中的运算优先级. 

696 | [对象初始化]40594 "") | **ECMAScript 2015, JavaScript, Literal, Methods, Object, Primary Expression, computed, mutation, properties** 
可以通过[`new Object()`]10219 "")，`[Object.create()]41405 "")`方法，或者使用字面量标记（初始化标记）初始化对象。 一个对象初始化器，由花括号/大括号 (`{}`) 包含的一个由零个或多个对象属性名和其关联值组成的一个逗号分隔的列表构成。 

697 | [扩展语句]41249 "") | **ECMAScript6, Iterator, JavaScript, spread syntax, 操作符, 遍历** 
**扩展语法**允许一个表达式在期望多个参数（用于函数调用）或多个元素（用于数组字面量）或多个变量（用于解构赋值）的位置扩展。 

698 | [按位操作符]40584 "") | **** 
**按位操作符（Bitwise operators）**将其操作数（operands）当作32位的比特序列（由0和1组成），而不是十进制、十六进制或八进制[数值]10157 "/en-US/docs/JavaScript/Reference/Global_Objects/Number")。例如，十进制数9，用二进制表示则为1001。按位操作符操作数字的二进制形式，但是返回值依然是标准的JavaScript数值。 

699 | [数组推导式]40582 "") | **JavaScript, Non-standard, 参考, 运算符** 
**数组推导式**是一种新的 JavaScript 表达式语法，使用它，你可以在一个原有数组的基础上快速的构造出（推导出）一个新的数组。 

700 | [旧式生成器函数]40592 "") | **生成器函数** 
**`function`**关键字可以用于在表达式中定义旧式的生成器函数。为使定义的函数为一个旧式的生成器函数，该函数的函数体中需要至少包含一个[`yield`]40612 "yield 关键字用来暂停和恢复一个生成器函数 ( (function* 或 legacy generator).")表达式。 

701 | [条件运算符]40587 "") | **JavaScript, 三元, 操作符** 
条件（三元）运算符是 JavaScript 仅有的使用三个操作数的运算符。本运算符经常作为`[if]22329 "")语句的简短形式来使用。` 

702 | [比较操作符]40586 "") | **严格比较操作符, 比较操作符** 
JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true，而对于被广泛使用的比较运算符（==）来说，会在进行比较之前，将两个操作数转换成相同的类型。对于关系运算符（比如 &lt;=）来说，会先将操作数转为原始值，使它们类型相同，再进行比较运算。 

703 | [算术运算符]40581 "") | **JavaScript, Operator** 
**算术运算符**以数值（字面量或变量）作为其操作数，并返回一个单个数值。标准算术运算符是加法（+），减法（ - ），乘法（*）和除法（/）。 

704 | [类表达式]40601 "") | **Class, Classes, ES6** 
**类表达式**是用来定义类的一种语法。和[函数表达式]43093 "")相同的一点是，类表达式可以是命名也可以是匿名的。如果是命名类表达式，这个名字只能在类体内部才能访问到。JavaScript 的类也是基于原型继承的。 

705 | [解构赋值]40588 "") | **Destructuring, ECMAScript 2015, JavaScript, Operator** 
**解构赋值**语法是一个 Javascript 表达式，这使得可以将**值从数组**或**属性从对象**提取到不同的变量中。 

706 | [赋值运算符]40583 "") | **运算符** 
赋值运算符（**assignment operator**）基于右值（right operand）的值，给左值（left operand）赋值。 

707 | [运算符优先级]40595 "") | **JavaScript, 优先级, 运算符** 
运算符的优先级决定了表达式中运算执行的先后顺序，优先级高的运算符最先被执行。 

708 | [逗号操作符]40585 "") | **comma operator, 逗号操作符** 
**No summary!** 

709 | [逻辑运算符]40593 "") | **** 
<br></br>逻辑运算符通常用于[布尔]40523 "")型（逻辑）值；这种情况，它们返回一个布尔型值。然而，&amp;&amp;和||运算符实际上返回一个指定操作数的值，因此这些运算符也用于非布尔型，它们返回一个非布尔型值。 

710 | [词法文法]40733 "") | **语法** 
这部分描述了JavaScript的词法。ECMAScript源码文本会被从左到右扫描，并被转换为一系列的输入元素，包括tokens、控制符、行终止符、注释和空白符。ECMAScript定义了一些关键字、字面量以及行尾分号补全的规则。 

711 | [迭代协议]13616 "") | **ECMAScript 2015, 可迭代协议, 迭代器协议** 
ECMAScript 2015的几个补充，并不是新的内置或语法，而是协议。这些协议可以被任何遵循某些约定的对象来实现。 

712 | [JavaScript 技术概览]40732 "") | **DOM, JavaScript** 
HTML是用来存储网页内容的，CSS是用来定义这些内容的显示样式的，而JavaScript是用来创造丰富的页面效果或者网页应用的。 

713 | [JavaScript 指南]40495 "") | **Guide, JavaScript** 
JavaScript 指南向你介绍如何使用[JavaScript]27624 "")，并且给出了语言概述。如果你需要了解某些语言特性的详细信息，请参阅[JavaScript 参考]40518 "")。 

714 | [JavaScript 概述]44217 "") | **ECMAScript** 
本节将介绍并讨论 JavaScript 的基本概念。 

715 | [Text formatting]40502 "") | **** 
本章介绍在Javascript中如何使用字符串与文本内容. 

716 | [Using promises]2396 "") | **** 
一个[`Promise`]4107 "Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义：诺言，一个成功，一个失败。)")就是一个代表了异步操作最终完成或者失败的对象. 一个promise可以使用它的[constructor]44218 "")创建。然而，大多数人都在使用由其他函数创建并返回的promise。因此，本教程将首先探讨返回promise的使用情况。 

717 | [介绍]40496 "") | **JavaScript, 指南** 
我们假设你已经掌握了以下基础技能： 

718 | [使用对象]40506 "") | **基本语法, 对象概述** 
JavaScript的设计是一个简单的基于对象的范式。一个对象就是一系列属性的集合，一个属性包含一个名和一个值。一个属性的值可以是函数，这种情况下属性也被称为*方法*。除了浏览器里面预定义的那些对象之外，你也可以定义你自己的对象。本章节讲述了怎么使用对象、属性、函数和方法，怎样实现自定义对象。 

719 | [元编程]40509 "") | **Guide, JavaScript, Proxy, Reflect** 
从ECMAScript 2015 开始，JavaScript 获得对[`Proxy`]40537 "Editorial review completed.")和[`Reflect`]40539 "Reflect 是一个内置的对象，它提供可拦截JavaScript操作的方法。方法与代理处理程序的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。")对象的支持，允许你拦截并定义基本语言操作的自定义行为（例如，属性查找，赋值，枚举，函数调用等）。借助这两个对象，你可以在 JavaScript 元级别进行编程。 

720 | [关于本指南]44219 "") | **JavaScript, 初学者, 指南** 
JavaScript 是一种跨平台的，基于对象的脚本语言。本指南介绍了所有您使用 JavaScript 所需要了解的事情。 

721 | [内置核心对象]44220 "") | **** 
本章描述在核心 JavaScript 中预定义的一些对象:`Array`,`Boolean`,`Date`,`Function`,`Math`,`Number`,`RegExp`, and`String`. 

722 | [再谈继承]44221 "") | **** 
在阅读本文之前，请先查看[继承与原型链]44222 "https://developer.mozilla.org/zh-CN/docs/JavaScript/Guide/Inheritance_and_the_prototype_chain")一文以了解关于 JavaScript 继承和构造器原型的知识。 

723 | [函数]23189 "") | **JavaScript, 函数, 初学者, 教程** 
函数是 JavaScript 中的基本组件之一。 一个函数是 JavaScript 过程 — 一组执行任务或计算值的语句。要使用一个函数，你必须将其定义在你希望调用它的作用域内。 

724 | [可迭代对象]43264 "") | **** 
The &quot;**iterable**&quot; protocol allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a[`for..of`]13613 "for...of语句在可迭代对象(包括 Array, Map, Set, String, TypedArray，arguments 对象等等)上创建一个迭代循环，对每个不同属性的属性值,调用一个自定义的有执行语句的迭代挂钩.")construct. Some built-in types, such as[`Array`]6708 "entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。")or[`Map`]40774 "此页面仍未被本地化, 期待您的翻译!"), have a default iteration behavior, while other types (such as[`Object`]10219 "Object 构造函数创建一个对象包装器。")) do not. 

725 | [对象模型的细节]40507 "") | **Guide, Intermediate, JavaScript, Object** 
JavaScript 是一种基于原型而不是基于类的面向对象语言。正是由于这一根本的区别，其如何创建对象的层级结构以及对象的属性与属性值是如何继承的并不是那么清晰。本节试着阐明。 

726 | [带键的集合]40505 "") | **Guide, JavaScript, Map, set, 集合** 
这一章介绍由key值标记的数据容器；Map 和 Set 对象承载的数据元素可以按照插入时的顺序被迭代遍历。 

727 | [循环和迭代]40499 "") | **JavaScript, 循环, 指南, 语法** 
循环提供了一种快速和简单的方式去做一些重复的事。[JavaScript入门]40800 "")的这个章节会介绍在JavaScript中存在哪些不同的迭代语句。 

728 | [数字和日期]40501 "") | **JavaScript, 指南** 
本章节介绍如何掌握Javascript里的数字和日期类型 

729 | [正则表达式]40503 "") | **JavaScript, Regular Expressions, 中级, 参考, 指南, 正则表达式** 
正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于[`RegExp`]40773 "此页面仍未被本地化, 期待您的翻译!")的[`exec`]41327 "exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。")和[`test`]41328 "test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。")方法, 以及[`String`]4402 "此页面仍未被本地化, 期待您的翻译!")的[`match`]41316 "当一个字符串与一个正则表达式匹配时， match()方法检索匹配项。")、[`replace`]41317 "replace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式, 替换值可以是一个字符串或者一个每次匹配都要调用的函数。")、[`search`]41318 "search() 方法执行正则表达式和 String对象之间的一个搜索匹配。")和[`split`]41312 "split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。")方法。本章介绍 JavaScript正则表达式。 

730 | [流程控制与错误处理]40498 "") | **JavaScript, 指南, 语句** 
JavaScript 提供一套灵活的语句集，特别是控制流语句，你可以用它在你的应用程序中实现大量的交互性功能。本章节我们将带来关于JavaScript语句的一些概览。 

731 | [索引集合类 (Indexed collections)]40504 "") | **** 
这个章节主要介绍了以索引进行排序的数据集合。包括数组以及类似于数组的数据结构，如**[`Array`]6708 "entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。")**、**[`TypedArray`]5141 "一个TypedArray 对象描述一个底层的二进制数据缓存区的一个类似数组(array-like)视图。没有名为 TypedArray的全局属性，也没有一个直接可见的 TypedArray构造函数。相反，有许多不同的全局属性，其值是下面列出的特定元素类型的类型化数组构造函数。在下面的页面中，你会找到可用于包含任何类型的元素的任何类型数组的常见属性和方法")**。 

732 | [表达式和运算符]40500 "") | **初学者, 指南, 表达式, 运算符** 
本章描述了 JavaScript 的表达式和运算符，包括了赋值，比较，算数，位运算，逻辑，字符串，三元等等。 

733 | [语法和数据类型]41073 "") | **Enhanced Object Literals, JavaScript, Null, Object Literals, Typed Objects, typeof(), 教程** 
本章讨论 JavaScript 的基本语法，变量声明，数据类型 和 字面量。 

734 | [迭代器和生成器]41126 "") | **Guide, Intermediate, JavaScript** 
处理集合中的每个项是很常见的操作。JavaScript 提供了许多迭代集合的方法，从简单的[`for`]40627 "for 语句用于创建一个循环，它包含了三个可选的表达式，三个可选的表达式包围在圆括号中并由分号分隔， 后跟一个在循环中执行的语句（通常是一个块语句）。")循环到[`map()`]3652 "map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。")[`filter()`]3634 "filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。")。迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义[`for...of`]13613 "for...of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。")循环的行为 。 

735 | [JavaScript 数据类型和数据结构]40511 "") | **JavaScript, 初学者, 数据结构, 类型** 
编程语言都具有内建的数据结构，但各种编程语言的数据结构常有不同之处。本文试图列出 JavaScript 语言中内建的数据结构及其属性，它们可以用来构建其他的数据结构；同时尽可能的描述与其他语言的不同之处。 

736 | [JavaScript 类型数组]22980 "") | **Array, Typed, Typed_arrays** 
JavaScript类型化数组是一种类似数组的对象，并提供了一种用于访问原始二进制数据的机制。 正如你可能已经知道，[`Array`]6708 "entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。")存储的对象能动态增多和减少，并且可以存储任何JavaScript值。JavaScript引擎会做一些内部优化，以便对数组的操作可以很快。然而，随着Web应用程序变得越来越强大，尤其一些新增加的功能例如：音频视频编辑，访问WebSockets的原始数据等，很明显有些时候如果使用JavaScript代码可以快速方便地通过类型化数组来操作原始的二进制数据将会非常有帮助。 

737 | [JavaScript更新]40737 "") | **ECMAScript, ECMAScript 2017, JavaScript, 版本** 
本章包含有关JavaScript版本历史记录的信息，以及基于**Mozilla/SpiderMonkey-**的JavaScript应用程序的实现状态，例如Firefox。 

738 | [ECMAScript 5 support in Mozilla]40739 "") | **** 
ECMAScript 5.1, an older version of the standard upon which JavaScript is based, was approved in June 2011. 

739 | [Firefox中的JavaScript更新日志]40741 "") | **JavaScript, 版本** 
下面是Firefox发布版本的JavaScript日志更新情况。 

740 | [JavaScript 1.1的新特性]40742 "") | **** 
下面介绍的是JavaScript从Netscape Navigator 2.0到3.0的更新日志。旧的Netscape文档请参考[&quot;第1版之后新增的特性&quot;]44127 "")。Netscape Navigator 3.0在1996年8月19发布，是支持JavaScript的浏览器的第二个主要的版本。 

741 | [JavaScript 1.2的新特性]40743 "") | **** 
下面介绍的是JavaScript从Netscape Navigator 3.0到4.0的更新日志。旧的Netscape文档可以在[archive.org]44131 "")上面找到。Netscape Navigator 4.0在1997年6月11日发布，它是是支持JavaScript的浏览器的第三个主要的版本。 

742 | [JavaScript 1.3的新特性]40744 "") | **** 
下面介绍的是JavaScript从Netscape Navigator 4.0到4.5的更新日志。旧的Netscape文档可以在[archive.org]44134 "")上面找到。Netscape Navigator 4.5是在1998年10月19日发布的。 

743 | [JavaScript 1.4的新特性]40745 "") | **** 
下面是 JavaScript 1.4 的更新记录，它只可用于 1999 年发布的 Netscape 服务端 JavaScript。 旧的 Netscape 文档可在[archive.org]44140 "")找到。 

744 | [JavaScript 1.5 的新特性]40746 "") | **JavaScript, 版本** 
以下为JavaScript 1.5 的更新日志。该版本包含在发行于2000年11月14日的Netscape Navigator 6.0中，也在后续的的Netscape Navigator版本和Firefox 1.0中使用。你可以拿JavaScript 1.5 和JScript version 5.5，Internet Explorer 5.5进行比较，后者发行于2000年7月。相应的ECMA 标准是 ECMA-262 Edition 3版 (自1999年12月)。 

745 | [JavaScript 1.6 的新特性]40747 "") | **JavaScript, 版本** 
**No summary!** 

746 | [JavaScript 1.7 的新特性]40748 "") | **** 
**No summary!** 

747 | [JavaScript 1.8.1 的新特性]40750 "") | **Firefox 3.5** 
下面是JavaScript 1.8.1 的更新内容. 该版本已包含在[Firefox 3.5]3393 "")中. 

748 | [JavaScript 1.8.5 的新特性]40751 "") | **** 
下面的内容是JavaScript 1.8.5的更新记录. 该版本已包含在[Firefox 4]3678 "")中. 

749 | [Mozilla对ECMAScript 6的支持]40738 "") | **ECMAScript2015, ECMAScript6, Firefox, JavaScript** 
**No summary!** 

750 | [Mozilla对下一代ECMAScript 的支持]40740 "") | **ES2016, ES2017, ES6, ES7, ES8, new features** 
下一代ECMAScript 是指在ECMAScript 6 (ES2015)被推出后的 ECMA-262标准的新特性(通常被称为[JavaScript]14321 "")). 即使在ECMAScript 6 于2015年6月17日完成之前，新的特性也早已在提议中. 你可以在[tc39/ecma262]43666 "")这个仓库中看见最新版的提议. 

751 | [New in JavaScript 1.8]40749 "") | **JavaScript, 版本** 
以下为JavaScript 1.8的更新日志。JavaScript 1.8 是 Gecko 1.9（已合并在[Firefox 3]44153 "cn/Firefox_3")中）的一部分。参见[bug 380236]44154 "FIXED: JS1.8 tracking bug")以跟踪 JavaScript 1.8。 

752 | [JavaScript资源]40764 "") | **JavaScript** 
**ECMAScript**是形成[JavaScript]44223 "")语言基础的脚本语言。ECMAScript是由[Ecma国际]41140 "http://www.ecma-international.org/")标准组织以**ECMA-262和ECMA-402规范**的形式进行标准化的。下面的ECMAScript标准已经通过批准： 

753 | [JavaScript面向对象简介]41501 "") | **JavaScript, OOP, 命名空间, 对象, 封装, 成员, 构造函数, 继承, 面向对象** 
JavaScript 的核心是支持面向对象的，同时它也提供了强大灵活的 OOP 语言能力。本文从对面向对象编程的介绍开始，带您探索 JavaScript 的对象模型，最后描述 JavaScript 当中面向对象编程的一些概念。 

754 | [SIMD types]40515 "") | **** 
关于SIMD的缺点，这也是为何算法要针对SIMD进行设计。当你的算法要分别处理不同的数据时，数据集中的不同数据并不能被区分处理。在后面的文章中我们将知道如何使用蒙板以及如何将数据重新对齐来解决这一问题。 

755 | [javascript(起步)]44224 "") | **** 
作为一门计算机语言，JavaScript本身强大、复杂，且难于理解。但是，你可以用它来开发一系列的应用程序，它有巨大的潜力来改变当前的互联网现状。下面这个应用程序就是一个很好的例子：[Google Maps]44225 "")。 

756 | [关于 JavaScript]40762 "") | **JavaScript, 入门介绍** 
JavaScript<sup>®</sup>（通常简写为JS）是一种轻量的、解释性的、面向对象的[头等函数]44226 "")语言，其最广为人知的应用是作为网页的脚本语言，但同时它也在很多[非浏览器环境下使用]44227 "")。JS是一种动态的[基于原型]44228 "")和多[范式]44229 "")的脚本语言，支持面向对象、命令式和函数式的编程风格。 

757 | [内存管理]40516 "") | **JavaScript, 内存, 性能** 
像C语言这样的高级语言一般都有低级的内存管理接口，比如`malloc()`和`free()`。另一方面，JavaScript创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放。 后一个过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者感觉他们可以不关心内存管理。 这是错误的。 

758 | [属性的可枚举性和所有权]40734 "") | **** 
可枚举属性是指那些内部 “可枚举” 标志设置为 true 的属性，对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true，对于通过[Object.defineProperty]25258 "")等定义的属性，该标识值默认为 false。可枚举的属性可以通过[for...in]40929 "")循环进行遍历（除非该属性名是一个[Symbol]40861 "")）。属性的所有权是通过判断该属性是否直接属于某个对象决定的，而不是通过原型链继承的。一个对象的所有的属性可以一次性的获取到。有一些内置的方法可以用于判断、迭代/枚举以及获取对象的一个或一组属性，下表对这些方法进行了列举。对于部分不可用的类别，下方的示例代码对获取方法进行了演示。 

759 | [并发模型与事件循环]40517 "") | **Advanced, Event Loop, JavaScript** 
JavaScript 的并发模型基于&quot;事件循环&quot;。这个模型与像 C 或者 Java 这种其它语言中的模型截然不同。 

760 | [索引]40752 "") | **JavaScript, mozilla开发网, 元数据** 
该页面列出了 MDN JavaScript 所有的页面及相关概览和标签。 

761 | [继承与原型链]40514 "") | **Advanced, Guide, Inheritance, JavaScript, OOP** 
对于有基于类的语言经验的开发人员来说，JavaScript 有点令人困惑 (如Java或C ++) ，因为它是动态的，并且本身不提供一个`class`实现。（在ES2015/ES6中引入了`class`关键字，但只是语法糖，JavaScript 仍然是基于原型的）。 

762 | [记录差异测试]44230 "") | **** 
hello 

763 | [起步(Javascript 教程)]44231 "") | **bug-840092** 
作为一门计算机语言，JavaScript本身强大、复杂，且难于理解。但是，你可以用它来开发一系列的应用程序，它有巨大的潜力来改变当前的互联网现状。下面这个应用程序就是一个很好的例子：[Google Maps]44225 "")。 

764 | [重新介绍 JavaScript（JS 教程）]40510 "") | **JavaScript, 教程, 进阶** 
为什么会有这一篇“重新介绍”呢？因为[JavaScript]443 "JavaScript: JavaScript (JS) is a programming language mostly used client-side to dynamically script webpages, but often also server-side, using packages such as Node.js.")堪称[世界上被人误解最深的编程语言]41486 "")。虽然常被嘲为“玩具语言”，但在它看似简洁的外衣下，还隐藏着强大的语言特性。 JavaScript 目前广泛应用于众多知名应用中，对于网页和移动开发者来说，深入理解 JavaScript 就尤有必要。 

765 | [闭包]40513 "") | **Closures, JavaScript, 指南, 进阶, 闭包** 
Closures (闭包)是使用被作用域封闭的变量，函数，闭包等执行的一个函数的作用域。通常我们用和其相应的函数来指代这些作用域。(可以访问独立数据的函数) 





